//! TODO

use fdb::error::{FdbError, FdbResult};
use fdb_rl_proto::fdb_rl::field::v1::Uuid as FdbRLWktUuidProto;
use prost_reflect::{
    Cardinality, FieldDescriptor, FileDescriptor, Kind, MessageDescriptor, ReflectMessage, Syntax,
};

use std::convert::TryFrom;
use std::ops::Deref;
use std::sync::LazyLock;

use super::error::KEY_EXPRESSION_ILL_FORMED_MESSAGE_DESCRIPTOR;

/// Well known types that are known to FDB Record Layer.
static FDB_RL_WKT: LazyLock<Vec<MessageDescriptor>> =
    LazyLock::new(|| vec![FdbRLWktUuidProto::default().descriptor()]);

// TODO: Remove later
//
// Takes a `prost_reflect::MessageDescriptor`, and performs checks to
// ensure that message descriptor is well formed. If it is well
// formed, it wraps the message descriptor and returns a value of type
// `WellFormedMessageDescriptor`.
//
// If you have a value of type `WellFormedMessageDescriptor`, you can
// be sure that the provided `prost_reflect::MessageDescriptor` is
// well formed.

/// TODO
#[derive(Debug, PartialEq)]
pub(crate) struct WellFormedMessageDescriptor {
    inner: MessageDescriptor,
}

impl TryFrom<MessageDescriptor> for WellFormedMessageDescriptor {
    type Error = FdbError;

    fn try_from(message_descriptor: MessageDescriptor) -> FdbResult<WellFormedMessageDescriptor> {
        let mut message_descriptor_validator_visitor = MessageDescriptorValidatorVisitor::new();

        if walk_message_descriptor(
            &mut message_descriptor_validator_visitor,
            &message_descriptor,
        ) {
            Ok(WellFormedMessageDescriptor {
                inner: message_descriptor,
            })
        } else {
            Err(FdbError::new(KEY_EXPRESSION_ILL_FORMED_MESSAGE_DESCRIPTOR))
        }
    }
}

trait Visitor {
    fn check_fdb_wkt(&self, message_descriptor: &MessageDescriptor) -> bool;

    fn previously_walked_check_or_update(&mut self, message_descriptor: &MessageDescriptor)
        -> bool;

    fn visit_parent_file_descriptor(&self, file_descriptor: FileDescriptor) -> bool;

    fn visit_field_descriptor(&mut self, field_descriptor: FieldDescriptor) -> bool;
}

fn walk_message_descriptor(
    visitor: &mut dyn Visitor,
    message_descriptor: &MessageDescriptor,
) -> bool {
    if visitor.previously_walked_check_or_update(message_descriptor) {
        // Have we seen this message descriptor before? If so, it is a
        // recursive message. Just return `true` here, and let message
        // validation happen at the place where it was first seen.
        true
    } else {
        // If message descriptor is a FDB Record Layer well known
        // type, there is nothing to be done. We return `true`.
        if visitor.check_fdb_wkt(message_descriptor) {
            return true;
        }

        // To understand the motivation for the checks we perform
        // below, see the documentation for type
        // `MessageDescriptorValidatorVisitor`.
        //
        // We just visit various parts of the message descriptor
        // below. The actual logic is implemented inside the visitor.

        if !visitor.visit_parent_file_descriptor(message_descriptor.parent_file()) {
            return false;
        }

        for field_descriptor in message_descriptor.fields() {
            if !visitor.visit_field_descriptor(field_descriptor) {
                return false;
            }
        }

        true
    }
}

/// There are two valid forms of field descriptor that we want.
///
/// 1. `cardinality: Optional`, `supports_presence: true`, `is_list:
///    false`, `default_value: None`, `containing_oneof: Some("...")`,
///    where `...` is the name of the oneof. `...` can be explicitly
///    provided when `oneof` keyword is used. Alternatively, when
///    `optional` is specified, it is generated by the protobuf
///    compiler.
///
/// 2. `cardinality: Repeated`, `supports_presence: false`, `is_list:
///    true`, `containing_oneof: None`. In proto3, there is no concept
///    of `optional repeated` [1].
///
/// When `cardinality: Optional`, `support_presence: false` and
/// `is_list: false`, that is a round about way of saying "required"
/// with default value. We do not allow that. The only way to specify
/// that a field is "required" is by using a not null key expression.
///
/// We outright reject `cardinality: Required`. If we see
/// `cardinality: Required`, there is some serious bug, as we are
/// checking for proto3 from file descriptor.
///
/// We also reject `is_group: true`, `is_map: true`, `is_packed:
/// true`, `default_value: Some(...)`. There is no API from
/// `FileDescriptor` type to check `default_value`. Therefore we need
/// to check using `FileDescriptorProto` type.
///
/// Protobuf message can have no fields. Together with `oneof` this is
/// very useful in building up discriminated unions (tagged union, sum
/// types). We use this technique in `key_expressions.proto`. The
/// problem with a message that has no fields is that there is no way
/// to use `Field` key expression on it. While we allow message with
/// no fields, this is something that the user must be aware
/// of. Semantically this is equivalent to targeting a field that does
/// not exist, so the key expression cannot be applied on the message.
///
/// We support `oneof` keyword. Oneof fields are just fields in the
/// enclosing message descriptor [2] and they have `containing_oneof:
/// Some("...")`, where `...` specified in `.proto` file rather than
/// being compiler generated. Fields that are part of `oneof` keyword
/// have `supports_presence: true`, `cardinality: Optional`.
///
/// As mentioned above, for a non-repeated field, `cardinality:
/// Optional`, `supports_presence: true`, `is_list: false`
/// `containing_oneof: Some("...")` is the form that we want.
///
/// Additionally, within oneof, there cannot be a `repeated` field
/// [3]. This ensures that we won't see an empty `repeated` field
/// within oneof.
///
/// Following message type gives us the correct form.
///
/// ```
/// message HelloWorld {
///   optional fdb_rl.field.v1.UUID primary_key = 1;
///   optional string hello = 2;
///   optional string world = 3;
/// }
/// ```
///
/// If we were to remove the `optional` keyword, for example:
///
/// ```
/// message HelloWorld {
///   fdb_rl.field.v1.UUID non_optional_primary_key = 4;
///   string non_optional_string = 5;
/// }
/// ```
///
/// Then the field `non_optional_primary_key` would have
/// `containing_oneof: None`. The field `non_optional_string` would
/// have `containing_oneof: None` *and* `supports_presence: false`.
///
/// We do not support protobuf `map` type. A `map` type is implemented
/// using a `repeated` field with a protobuf generated message
/// type. This generated message type consists of two fields - key and
/// value whose types are the type parameters for the `map` type.
///
/// The `key` and `value` fields has `support_presence: false` and
/// `cardiality: Optional`, which is a weird way means "required"
/// field. The only way we allow for specifying a field is "required"
/// is by using a key expression and not within protobuf.
///
/// Therefore, the semantics of key expression is not clear for `map`
/// type. There are no good test cases from Java RecordLayer that we
/// can use here. So, for now, we will not support `map` type. In the
/// meantime, if the user needs a map type, they can use the same
/// trick as what the protobuf compiler does (which is define a
/// repeated field with a message and do the checking in code).
///
/// [1]: https://github.com/protocolbuffers/protobuf/issues/10489
/// [2]: https://protobuf.com/docs/language-spec#fully-qualified-names
/// [3]: https://protobuf.dev/programming-guides/proto3/#using-oneof
#[derive(Debug)]
struct MessageDescriptorValidatorVisitor {
    walked_message_descriptor: Vec<MessageDescriptor>,
}

impl MessageDescriptorValidatorVisitor {
    fn new() -> MessageDescriptorValidatorVisitor {
        MessageDescriptorValidatorVisitor {
            walked_message_descriptor: Vec::new(),
        }
    }
}

impl Visitor for MessageDescriptorValidatorVisitor {
    /// Checks if the message descriptor is a FDB Record Layer well
    /// known type.
    fn check_fdb_wkt(&self, message_descriptor: &MessageDescriptor) -> bool {
        FDB_RL_WKT.deref().contains(message_descriptor)
    }

    /// Checks if we have seen the message descriptor before. If not,
    /// we update that we have seen it and returns `false`. Therefore,
    /// next time we are called, we can return `true`.
    fn previously_walked_check_or_update(
        &mut self,
        message_descriptor: &MessageDescriptor,
    ) -> bool {
        if self.walked_message_descriptor.contains(message_descriptor) {
            true
        } else {
            self.walked_message_descriptor
                .push(message_descriptor.clone());
            false
        }
    }

    /// Returns `true` if `.proto` file was compiled using `syntax =
    /// proto3`.
    fn visit_parent_file_descriptor(&self, file_descriptor: FileDescriptor) -> bool {
        matches!(file_descriptor.syntax(), Syntax::Proto3)
    }

    /// Returns `true` if the field descriptor is considered
    /// "valid".
    ///
    /// See documentation on type
    /// [`MessageDescriptorValidatorVisitor`] for details.
    fn visit_field_descriptor(&mut self, field_descriptor: FieldDescriptor) -> bool {
        if field_descriptor.is_group()
            || field_descriptor.is_map()
            || field_descriptor.is_packed()
            || field_descriptor
                .field_descriptor_proto()
                .default_value
                .is_some()
        {
            return false;
        }

        match field_descriptor.cardinality() {
            Cardinality::Optional => {
                if field_descriptor.supports_presence()
                    && !field_descriptor.is_list()
                    && field_descriptor.containing_oneof().is_some()
                {
                    // Match all kinds explicitly so that in the
                    // unlikely event a new kind gets introduced in
                    // the future, we do not miss it.
                    match field_descriptor.kind() {
                        Kind::Message(inner_message_descriptor) => {
                            walk_message_descriptor(self, &inner_message_descriptor)
                        }
                        Kind::Double
                        | Kind::Float
                        | Kind::Int32
                        | Kind::Int64
                        | Kind::Uint32
                        | Kind::Uint64
                        | Kind::Sint32
                        | Kind::Sint64
                        | Kind::Fixed32
                        | Kind::Fixed64
                        | Kind::Sfixed32
                        | Kind::Sfixed64
                        | Kind::Bool
                        | Kind::String
                        | Kind::Bytes
                        | Kind::Enum(_) => true,
                    }
                } else {
                    false
                }
            }
            Cardinality::Required => false,
            Cardinality::Repeated => {
                if !field_descriptor.supports_presence()
                    && field_descriptor.is_list()
                    && field_descriptor.containing_oneof().is_none()
                {
                    // Match all kinds explicitly so that in the
                    // unlikely event a new kind gets introduced in
                    // the future, we do not miss it.
                    match field_descriptor.kind() {
                        Kind::Message(inner_message_descriptor) => {
                            walk_message_descriptor(self, &inner_message_descriptor)
                        }
                        Kind::Double
                        | Kind::Float
                        | Kind::Int32
                        | Kind::Int64
                        | Kind::Uint32
                        | Kind::Uint64
                        | Kind::Sint32
                        | Kind::Sint64
                        | Kind::Fixed32
                        | Kind::Fixed64
                        | Kind::Sfixed32
                        | Kind::Sfixed64
                        | Kind::Bool
                        | Kind::String
                        | Kind::Bytes
                        | Kind::Enum(_) => true,
                    }
                } else {
                    false
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    mod well_formed_message_descriptor {
        use bytes::Bytes;
        use fdb::error::FdbError;
        use fdb_rl_proto::fdb_rl::field::v1::Uuid as UuidProto;
        use fdb_rl_proto::fdb_rl_test::key_expression::well_formed_message_descriptor::bad::v1::HelloWorld as HelloWorldProto2;
        use fdb_rl_proto::fdb_rl_test::key_expression::well_formed_message_descriptor::good::v1::HelloWorld as HelloWorldProto3;
        use prost_reflect::ReflectMessage;
        use uuid;

        use std::convert::TryFrom;

        use super::super::super::error::KEY_EXPRESSION_ILL_FORMED_MESSAGE_DESCRIPTOR;
        use super::super::WellFormedMessageDescriptor;

        #[test]
        fn try_from_message_descriptor_try_from() {
            // Invalid message descriptor
            {
                let hello_world = HelloWorldProto2 {
                    hello: "hello".to_string(),
                    world: Some("world".to_string()),
                };

                let message_descriptor = hello_world.descriptor();

                assert_eq!(
                    WellFormedMessageDescriptor::try_from(message_descriptor),
                    Err(FdbError::new(KEY_EXPRESSION_ILL_FORMED_MESSAGE_DESCRIPTOR))
                );
            }

            // Valid Message descriptor
            {
                let hello_world = HelloWorldProto3 {
                    primary_key: Some(UuidProto {
                        value: Bytes::from(
                            uuid::Uuid::parse_str("ffffffff-ba5e-ba11-0000-00005ca1ab1e")
                                .unwrap()
                                .as_bytes()
                                .to_vec(),
                        ),
                    }),
                    hello: Some("hello".to_string()),
                    world: Some("world".to_string()),
                };

                let message_descriptor = hello_world.descriptor();

                assert_eq!(
                    WellFormedMessageDescriptor::try_from(message_descriptor.clone()),
                    Ok(WellFormedMessageDescriptor {
                        inner: message_descriptor,
                    })
                );
            }
        }
    }
}
