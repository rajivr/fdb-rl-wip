<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Reading and writing `Element`s"><title>ion_rs - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-07416f8512e0e04c.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="ion_rs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.73.0-nightly (da6b55cc5 2023-07-17)" data-channel="nightly" data-search-js="search-f6292fe389d70017.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-6d2c9675f3d09c26.css" data-theme-dark-css="dark-45ceb8f2e522f4d1.css" data-theme-ayu-css="ayu-fd19013d6ce078bf.css" ><script src="../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-6d2c9675f3d09c26.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-45ceb8f2e522f4d1.css"><link rel="stylesheet" href="../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../ion_rs/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../ion_rs/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate ion_rs</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.18.1</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Definitions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">ion_rs</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/ion_rs/lib.rs.html#1-246">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="reading-and-writing-elements"><a href="#reading-and-writing-elements">Reading and writing <code>Element</code>s</a></h2>
<p>The <a href="element/struct.Element.html" title="struct ion_rs::element::Element">Element</a> API offers a convenient way to read and write Ion data when its exact shape is
not known ahead of time.</p>
<p>Each <code>Element</code> represents an <code>(annotations, value)</code> pair. If the value is a container (an Ion
<code>list</code>, <code>sexp</code>, or <code>struct</code>), then it will contain its own collection of <code>Element</code>s. <code>Element</code>s
can be nested to arbitrary depth.</p>
<h3 id="constructing-an-element"><a href="#constructing-an-element">Constructing an <code>Element</code></a></h3><h4 id="from-text-ion"><a href="#from-text-ion">From text Ion</a></h4>
<p>The <a href="element/struct.Element.html#method.read_one" title="associated function ion_rs::element::Element::read_one">Element::read_one</a> method will parse the provided data and requires that it contain exactly
one Ion value.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ion_rs::element::Element;
<span class="kw">use </span>ion_rs::IonType;
<span class="kw">let </span>ion_data = <span class="string">&quot;[1, 2, 3]&quot;</span>;
<span class="kw">let </span>element = Element::read_one(ion_data)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(element.ion_type(), IonType::List);</code></pre></div>
<p><a href="element/struct.Element.html#method.read_all" title="associated function ion_rs::element::Element::read_all">Element::read_all</a> will read any number of Ion values and return them as a <code>Vec&lt;Element&gt;</code>.</p>
<p><a href="element/struct.Element.html#method.read_first" title="associated function ion_rs::element::Element::read_first">Element::read_first</a> will read the first Ion value without requiring that the stream have
exactly one value.</p>
<h4 id="from-a-rust-value"><a href="#from-a-rust-value">From a Rust value</a></h4>
<p>Most Rust primitives implement <code>Into&lt;Element&gt;</code>, allowing them to be converted to an Ion <a href="element/struct.Element.html" title="struct ion_rs::element::Element">Element</a>
directly.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ion_rs::element::Element;

<span class="kw">let </span>int: Element = <span class="number">5</span>.into();
<span class="macro">assert_eq!</span>(Element::read_one(<span class="string">&quot;5&quot;</span>)<span class="question-mark">?</span>, int);

<span class="kw">let </span>boolean: Element = <span class="bool-val">true</span>.into();
<span class="macro">assert_eq!</span>(Element::read_one(<span class="string">&quot;true&quot;</span>)<span class="question-mark">?</span>, boolean);

<span class="kw">let </span>string: Element = <span class="string">&quot;hello&quot;</span>.into();
<span class="macro">assert_eq!</span>(Element::read_one(<span class="string">&quot;\&quot;hello\&quot;&quot;</span>)<span class="question-mark">?</span>, string);

<span class="kw">let </span>ion_version_marker: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0xE0</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0xEA</span>]; <span class="comment">// Ion 1.0 version marker
</span><span class="kw">let </span>blob: Element = ion_version_marker.into();
<span class="macro">assert_eq!</span>(Element::read_one(<span class="string">&quot;{{4AEA6g==}}&quot;</span>)<span class="question-mark">?</span>, blob);</code></pre></div>
<h4 id="using-macros"><a href="#using-macros">Using macros</a></h4>
<p>When constructing a container <a href="element/struct.Element.html" title="struct ion_rs::element::Element">Element</a>, you can use the <a href="element/builders/macro.ion_list.html" title="macro ion_rs::element::builders::ion_list"><code>ion_list!</code></a>, <a href="element/builders/macro.ion_sexp.html" title="macro ion_rs::element::builders::ion_sexp"><code>ion_sexp!</code></a>,
and <a href="element/builders/macro.ion_struct.html" title="macro ion_rs::element::builders::ion_struct"><code>ion_struct!</code></a> macros.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ion_rs::element::Element;
<span class="kw">use </span>ion_rs::{ion_list, ion_sexp, ion_struct};

<span class="comment">// Variable names are allowed
</span><span class="kw">let </span>six = <span class="number">6i64</span>;
<span class="kw">let </span>list: Element = <span class="macro">ion_list! </span>[<span class="bool-val">true</span>, six, <span class="string">&quot;foo&quot;</span>].into();
<span class="macro">assert_eq!</span>(Element::read_one(<span class="string">&quot;[true, 6, \&quot;foo\&quot;]&quot;</span>)<span class="question-mark">?</span>, list);

<span class="comment">// Nested use of macros is allowed
// Notice that ion_sexp! uses ()s without commas
</span><span class="kw">let </span>sexp: Element = <span class="macro">ion_sexp! </span>(<span class="bool-val">true </span>six <span class="macro">ion_list!</span>[<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>]).into();
<span class="macro">assert_eq!</span>(Element::read_one(<span class="string">&quot;(true 6 [\&quot;foo\&quot;, \&quot;bar\&quot;])&quot;</span>)<span class="question-mark">?</span>, sexp);

<span class="kw">let </span>field_name = <span class="string">&quot;bar&quot;</span>;
<span class="kw">let </span>struct_: Element = <span class="macro">ion_struct! </span>{
  <span class="string">&quot;foo&quot;</span>: six,
  field_name: <span class="bool-val">false
</span>}.into();
<span class="macro">assert_eq!</span>(Element::read_one(<span class="string">&quot;{foo: 6, bar: false}&quot;</span>)<span class="question-mark">?</span>, struct_);</code></pre></div>
<h4 id="from-a-stream"><a href="#from-a-stream">From a stream</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ion_rs::element::reader::ElementReader;
<span class="kw">use </span>ion_rs::element::Element;
<span class="kw">use </span>ion_rs::ReaderBuilder;
<span class="kw">use </span>std::fs::File;
<span class="kw">let </span>ion_file = File::open(<span class="string">&quot;/foo/bar/baz.ion&quot;</span>).unwrap();
<span class="kw">let </span><span class="kw-2">mut </span>reader = ReaderBuilder::default().build(ion_file)<span class="question-mark">?</span>;
<span class="comment">// A simple pretty-printer
</span><span class="kw">for </span>element <span class="kw">in </span>reader.elements() {
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, element<span class="question-mark">?</span>)
}</code></pre></div>
<h3 id="traversing-an-element"><a href="#traversing-an-element">Traversing an <code>Element</code></a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ion_rs::IonResult;
<span class="kw">use </span>ion_rs::element::{Element, IntoAnnotatedElement, Value};
<span class="kw">use </span>ion_rs::{ion_list, ion_struct};
<span class="kw">let </span>element: Element = <span class="macro">ion_struct! </span>{
  <span class="string">&quot;foo&quot;</span>: <span class="string">&quot;hello&quot;</span>,
  <span class="string">&quot;bar&quot;</span>: <span class="bool-val">true</span>,
  <span class="string">&quot;baz&quot;</span>: <span class="macro">ion_list! </span>[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]
}
.into();

<span class="kw">if let </span>Value::Struct(s) = element.value() {
    <span class="kw">if let </span><span class="prelude-val">Some</span>(Value::List(l)) = s.get(<span class="string">&quot;baz&quot;</span>).map(|b| b.value()) {
        <span class="kw">for </span>(index, element) <span class="kw">in </span>l.elements().enumerate() {
            <span class="macro">println!</span>(<span class="string">&quot;{}. {}&quot;</span>, index + <span class="number">1</span>, element);
            <span class="comment">// 1) 4
            // 2) 5
            // 3) 6
        </span>}
    }
}</code></pre></div>
<h3 id="writing-an-element-to-an-iowrite"><a href="#writing-an-element-to-an-iowrite">Writing an <code>Element</code> to an <code>io::Write</code></a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ion_rs::IonResult;
<span class="kw">use </span>ion_rs::element::writer::ElementWriter;
<span class="kw">use </span>ion_rs::element::{Element, IntoAnnotatedElement, Value};
<span class="kw">use </span>ion_rs::{ion_list, ion_struct, IonWriter, TextWriterBuilder};
<span class="kw">let </span>element: Element = <span class="macro">ion_struct! </span>{
  <span class="string">&quot;foo&quot;</span>: <span class="string">&quot;hello&quot;</span>,
  <span class="string">&quot;bar&quot;</span>: <span class="bool-val">true</span>,
  <span class="string">&quot;baz&quot;</span>: <span class="macro">ion_list! </span>[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]
}
.into();

<span class="kw">let </span><span class="kw-2">mut </span>buffer: Vec&lt;u8&gt; = Vec::new();
<span class="kw">let </span><span class="kw-2">mut </span>writer = TextWriterBuilder::default().build(<span class="kw-2">&amp;mut </span>buffer)<span class="question-mark">?</span>;
writer.write_element(<span class="kw-2">&amp;</span>element)<span class="question-mark">?</span>;
writer.flush()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    <span class="string">&quot;{foo: \&quot;hello\&quot;, bar: true, baz: [4, 5, 6]}&quot;</span>.as_bytes(),
    writer.output().as_slice()
);</code></pre></div>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.Decimal"><code>pub use types::<a class="struct" href="types/struct.Decimal.html" title="struct ion_rs::types::Decimal">Decimal</a>;</code></div></li><li><div class="item-name" id="reexport.Int"><code>pub use types::<a class="enum" href="types/enum.Int.html" title="enum ion_rs::types::Int">Int</a>;</code></div></li><li><div class="item-name" id="reexport.IonType"><code>pub use types::<a class="enum" href="types/enum.IonType.html" title="enum ion_rs::types::IonType">IonType</a>;</code></div></li><li><div class="item-name" id="reexport.Str"><code>pub use types::<a class="struct" href="types/struct.Str.html" title="struct ion_rs::types::Str">Str</a>;</code></div></li><li><div class="item-name" id="reexport.Symbol"><code>pub use types::<a class="struct" href="types/struct.Symbol.html" title="struct ion_rs::types::Symbol">Symbol</a>;</code></div></li><li><div class="item-name" id="reexport.Timestamp"><code>pub use types::<a class="struct" href="types/struct.Timestamp.html" title="struct ion_rs::types::Timestamp">Timestamp</a>;</code></div></li><li><div class="item-name" id="reexport.BinaryWriter"><code>pub use binary::binary_writer::<a class="struct" href="binary/binary_writer/struct.BinaryWriter.html" title="struct ion_rs::binary::binary_writer::BinaryWriter">BinaryWriter</a>;</code></div></li><li><div class="item-name" id="reexport.BinaryWriterBuilder"><code>pub use binary::binary_writer::<a class="struct" href="binary/binary_writer/struct.BinaryWriterBuilder.html" title="struct ion_rs::binary::binary_writer::BinaryWriterBuilder">BinaryWriterBuilder</a>;</code></div></li><li><div class="item-name" id="reexport.RawBinaryWriter"><code>pub use binary::raw_binary_writer::<a class="struct" href="binary/raw_binary_writer/struct.RawBinaryWriter.html" title="struct ion_rs::binary::raw_binary_writer::RawBinaryWriter">RawBinaryWriter</a>;</code></div></li><li><div class="item-name" id="reexport.RawReader"><code>pub use raw_reader::<a class="trait" href="raw_reader/trait.RawReader.html" title="trait ion_rs::raw_reader::RawReader">RawReader</a>;</code></div></li><li><div class="item-name" id="reexport.RawStreamItem"><code>pub use raw_reader::<a class="enum" href="raw_reader/enum.RawStreamItem.html" title="enum ion_rs::raw_reader::RawStreamItem">RawStreamItem</a>;</code></div></li><li><div class="item-name" id="reexport.Reader"><code>pub use reader::<a class="type" href="reader/type.Reader.html" title="type ion_rs::reader::Reader">Reader</a>;</code></div></li><li><div class="item-name" id="reexport.ReaderBuilder"><code>pub use reader::<a class="struct" href="reader/struct.ReaderBuilder.html" title="struct ion_rs::reader::ReaderBuilder">ReaderBuilder</a>;</code></div></li><li><div class="item-name" id="reexport.StreamItem"><code>pub use reader::<a class="enum" href="reader/enum.StreamItem.html" title="enum ion_rs::reader::StreamItem">StreamItem</a>;</code></div></li><li><div class="item-name" id="reexport.UserReader"><code>pub use reader::<a class="struct" href="reader/struct.UserReader.html" title="struct ion_rs::reader::UserReader">UserReader</a>;</code></div></li><li><div class="item-name" id="reexport.RawTextWriter"><code>pub use text::raw_text_writer::<a class="struct" href="text/raw_text_writer/struct.RawTextWriter.html" title="struct ion_rs::text::raw_text_writer::RawTextWriter">RawTextWriter</a>;</code></div></li><li><div class="item-name" id="reexport.RawTextWriterBuilder"><code>pub use text::raw_text_writer::<a class="struct" href="text/raw_text_writer/struct.RawTextWriterBuilder.html" title="struct ion_rs::text::raw_text_writer::RawTextWriterBuilder">RawTextWriterBuilder</a>;</code></div></li><li><div class="item-name" id="reexport.IonError"><code>pub use result::<a class="enum" href="result/enum.IonError.html" title="enum ion_rs::result::IonError">IonError</a>;</code></div></li><li><div class="item-name" id="reexport.IonResult"><code>pub use result::<a class="type" href="result/type.IonResult.html" title="type ion_rs::result::IonResult">IonResult</a>;</code></div></li></ul><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="binary/index.html" title="mod ion_rs::binary">binary</a></div><div class="desc docblock-short">This module provides the necessary structures and logic to read values from a binary Ion
data stream.</div></li><li><div class="item-name"><a class="mod" href="constants/index.html" title="mod ion_rs::constants">constants</a></div></li><li><div class="item-name"><a class="mod" href="data_source/index.html" title="mod ion_rs::data_source">data_source</a></div></li><li><div class="item-name"><a class="mod" href="element/index.html" title="mod ion_rs::element">element</a></div><div class="desc docblock-short">Provides a dynamically typed, materialized representation of an Ion value.</div></li><li><div class="item-name"><a class="mod" href="external/index.html" title="mod ion_rs::external">external</a></div><div class="desc docblock-short">Re-exports of third party dependencies that are part of our public API.</div></li><li><div class="item-name"><a class="mod" href="raw_reader/index.html" title="mod ion_rs::raw_reader">raw_reader</a></div></li><li><div class="item-name"><a class="mod" href="reader/index.html" title="mod ion_rs::reader">reader</a></div></li><li><div class="item-name"><a class="mod" href="result/index.html" title="mod ion_rs::result">result</a></div></li><li><div class="item-name"><a class="mod" href="text/index.html" title="mod ion_rs::text">text</a></div></li><li><div class="item-name"><a class="mod" href="types/index.html" title="mod ion_rs::types">types</a></div><div class="desc docblock-short">This module provides an implementation of the data types described by the
<a href="https://amazon-ion.github.io/ion-docs/docs/spec.html#the-ion-data-model">Ion Data Model</a>
section of the Ion 1.0 spec.</div></li></ul><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.ion_list.html" title="macro ion_rs::ion_list">ion_list</a></div><div class="desc docblock-short">Constructs a list <a href="element/struct.Element.html" title="struct ion_rs::element::Element"><code>Element</code></a> with the specified child values.</div></li><li><div class="item-name"><a class="macro" href="macro.ion_sexp.html" title="macro ion_rs::ion_sexp">ion_sexp</a></div><div class="desc docblock-short">Constructs an s-expression <a href="element/struct.Element.html" title="struct ion_rs::element::Element"><code>Element</code></a> with the specified child values.</div></li><li><div class="item-name"><a class="macro" href="macro.ion_struct.html" title="macro ion_rs::ion_struct">ion_struct</a></div><div class="desc docblock-short">Constructs an struct <a href="element/struct.Element.html" title="struct ion_rs::element::Element"><code>Element</code></a> with the specified fields.</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.BlockingRawReader.html" title="struct ion_rs::BlockingRawReader">BlockingRawReader</a></div><div class="desc docblock-short">The BlockingRawReader wraps a non-blocking RawReader that implements the BufferedReader trait,
providing a blocking RawReader.</div></li><li><div class="item-name"><a class="struct" href="struct.IonData.html" title="struct ion_rs::IonData">IonData</a></div><div class="desc docblock-short">A wrapper for lifting Ion compatible data into using Ion-oriented comparisons (versus the Rust
value semantics). This enables the default semantics to be what a Rust user expects for native
values, but allows a user to opt-in to Ion’s structural equivalence/order.</div></li><li><div class="item-name"><a class="struct" href="struct.SymbolRef.html" title="struct ion_rs::SymbolRef">SymbolRef</a></div><div class="desc docblock-short">A reference to a fully resolved symbol. Like <code>Symbol</code> (a fully resolved symbol with a
static lifetime), a <code>SymbolRef</code> may have known or undefined text (i.e. <code>$0</code>).</div></li><li><div class="item-name"><a class="struct" href="struct.SymbolTable.html" title="struct ion_rs::SymbolTable">SymbolTable</a></div><div class="desc docblock-short">Stores mappings from Symbol IDs to text and vice-versa.</div></li><li><div class="item-name"><a class="struct" href="struct.SystemReader.html" title="struct ion_rs::SystemReader">SystemReader</a></div><div class="desc docblock-short">A streaming Ion reader that:</div></li><li><div class="item-name"><a class="struct" href="struct.TextWriter.html" title="struct ion_rs::TextWriter">TextWriter</a></div><div class="desc docblock-short">An application-level text Ion writer. This writer manages a symbol table and so can convert
symbol IDs to their corresponding text. However, unlike the BinaryWriter, it is capable of writing
text to the output stream without first adding it to the symbol table.</div></li><li><div class="item-name"><a class="struct" href="struct.TextWriterBuilder.html" title="struct ion_rs::TextWriterBuilder">TextWriterBuilder</a></div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.RawSymbolToken.html" title="enum ion_rs::RawSymbolToken">RawSymbolToken</a></div><div class="desc docblock-short">A symbol token encountered in a text or binary Ion stream.
<a href="enum.RawSymbolToken.html" title="enum ion_rs::RawSymbolToken">RawSymbolToken</a>s do not store import source information for the token encountered. Similarly,
a <a href="enum.RawSymbolToken.html" title="enum ion_rs::RawSymbolToken">RawSymbolToken</a> cannot store both a symbol ID <em>and</em> text, which means that it is not suitable
for representing a resolved symbol.</div></li><li><div class="item-name"><a class="enum" href="enum.RawSymbolTokenRef.html" title="enum ion_rs::RawSymbolTokenRef">RawSymbolTokenRef</a></div><div class="desc docblock-short">Like RawSymbolToken, but the Text variant holds a borrowed reference instead of a String.</div></li><li><div class="item-name"><a class="enum" href="enum.SystemStreamItem.html" title="enum ion_rs::SystemStreamItem">SystemStreamItem</a></div><div class="desc docblock-short">Raw stream elements that a SystemReader may encounter.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.IonDataSource.html" title="trait ion_rs::IonDataSource">IonDataSource</a></div><div class="desc docblock-short">Optimized read operations for parsing Ion.</div></li><li><div class="item-name"><a class="trait" href="trait.IonReader.html" title="trait ion_rs::IonReader">IonReader</a></div><div class="desc docblock-short">This trait captures the format-agnostic parser functionality needed to navigate within an Ion
stream and read the values encountered into native Rust data types.</div></li><li><div class="item-name"><a class="trait" href="trait.IonWriter.html" title="trait ion_rs::IonWriter">IonWriter</a></div><div class="desc docblock-short">This trait captures the format-agnostic encoding functionality needed to write native Rust types
to a stream as Ion values.</div></li></ul><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.BlockingRawBinaryReader.html" title="type ion_rs::BlockingRawBinaryReader">BlockingRawBinaryReader</a></div></li><li><div class="item-name"><a class="type" href="type.BlockingRawTextReader.html" title="type ion_rs::BlockingRawTextReader">BlockingRawTextReader</a></div></li></ul></section></div></main></body></html>