<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Converting decimal strings into IEEE 754 binary floating point numbers."><title>pin_utils::core_reexport::num::dec2flt - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-07416f8512e0e04c.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="pin_utils" data-themes="" data-resource-suffix="" data-rustdoc-version="1.73.0-nightly (da6b55cc5 2023-07-17)" data-channel="nightly" data-search-js="search-f6292fe389d70017.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-6d2c9675f3d09c26.css" data-theme-dark-css="dark-45ceb8f2e522f4d1.css" data-theme-ayu-css="ayu-fd19013d6ce078bf.css" ><script src="../../../../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="../../../../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../../static.files/light-6d2c9675f3d09c26.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../../static.files/dark-45ceb8f2e522f4d1.css"><link rel="stylesheet" href="../../../../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../../pin_utils/index.html"><img class="rust-logo" src="../../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../../pin_utils/index.html"><img class="rust-logo" src="../../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module dec2flt</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‚ÄòS‚Äô to search, ‚Äò?‚Äô for more options‚Ä¶" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../../index.html">pin_utils</a>::<wbr><a href="../../index.html">core_reexport</a>::<wbr><a href="../index.html">num</a>::<wbr><a class="mod" href="#">dec2flt</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="https://doc.rust-lang.org/nightly/src/core/num/mod.rs.html#32">source</a> ¬∑ <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>dec2flt</code>)</span></div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Converting decimal strings into IEEE 754 binary floating point numbers.</p>
<h2 id="problem-statement"><a href="#problem-statement">Problem statement</a></h2>
<p>We are given a decimal string such as <code>12.34e56</code>. This string consists of integral (<code>12</code>),
fractional (<code>34</code>), and exponent (<code>56</code>) parts. All parts are optional and interpreted as zero
when missing.</p>
<p>We seek the IEEE 754 floating point number that is closest to the exact value of the decimal
string. It is well-known that many decimal strings do not have terminating representations in
base two, so we round to 0.5 units in the last place (in other words, as well as possible).
Ties, decimal values exactly half-way between two consecutive floats, are resolved with the
half-to-even strategy, also known as banker‚Äôs rounding.</p>
<p>Needless to say, this is quite hard, both in terms of implementation complexity and in terms
of CPU cycles taken.</p>
<h2 id="implementation"><a href="#implementation">Implementation</a></h2>
<p>First, we ignore signs. Or rather, we remove it at the very beginning of the conversion
process and re-apply it at the very end. This is correct in all edge cases since IEEE
floats are symmetric around zero, negating one simply flips the first bit.</p>
<p>Then we remove the decimal point by adjusting the exponent: Conceptually, <code>12.34e56</code> turns
into <code>1234e54</code>, which we describe with a positive integer <code>f = 1234</code> and an integer <code>e = 54</code>.
The <code>(f, e)</code> representation is used by almost all code past the parsing stage.</p>
<p>We then try a long chain of progressively more general and expensive special cases using
machine-sized integers and small, fixed-sized floating point numbers (first <code>f32</code>/<code>f64</code>, then
a type with 64 bit significand). The extended-precision algorithm
uses the Eisel-Lemire algorithm, which uses a 128-bit (or 192-bit)
representation that can accurately and quickly compute the vast majority
of floats. When all these fail, we bite the bullet and resort to using
a large-decimal representation, shifting the digits into range, calculating
the upper significant bits and exactly round to the nearest representation.</p>
<p>Another aspect that needs attention is the <code>RawFloat</code> trait by which almost all functions
are parametrized. One might think that it‚Äôs enough to parse to <code>f64</code> and cast the result to
<code>f32</code>. Unfortunately this is not the world we live in, and this has nothing to do with using
base two or half-to-even rounding.</p>
<p>Consider for example two types <code>d2</code> and <code>d4</code> representing a decimal type with two decimal
digits and four decimal digits each and take ‚Äú0.01499‚Äù as input. Let‚Äôs use half-up rounding.
Going directly to two decimal digits gives <code>0.01</code>, but if we round to four digits first,
we get <code>0.0150</code>, which is then rounded up to <code>0.02</code>. The same principle applies to other
operations as well, if you want 0.5 ULP accuracy you need to do <em>everything</em> in full precision
and round <em>exactly once, at the end</em>, by considering all truncated bits at once.</p>
<p>Primarily, this module and its children implement the algorithms described in:
‚ÄúNumber Parsing at a Gigabyte per Second‚Äù, available online:
<a href="https://arxiv.org/abs/2101.11408">https://arxiv.org/abs/2101.11408</a>.</p>
<h2 id="other"><a href="#other">Other</a></h2>
<p>The conversion should <em>never</em> panic. There are assertions and explicit panics in the code,
but they should never be triggered and only serve as internal sanity checks. Any panics should
be considered a bug.</p>
<p>There are unit tests but they are woefully inadequate at ensuring correctness, they only cover
a small percentage of possible errors. Far more extensive tests are located in the directory
<code>src/etc/test-float-parse</code> as a Python script.</p>
<p>A note on integer overflow: Many parts of this file perform arithmetic with the decimal
exponent <code>e</code>. Primarily, we shift the decimal point around: Before the first decimal digit,
after the last decimal digit, and so on. This could overflow if done carelessly. We rely on
the parsing submodule to only hand out sufficiently small exponents, where ‚Äúsufficient‚Äù means
‚Äúsuch that the exponent +/- the number of decimal digits fits into a 64 bit integer‚Äù.
Larger exponents are accepted, but we don‚Äôt do arithmetic with them, they are immediately
turned into {positive,negative} {zero,infinity}.</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="float/index.html" title="mod pin_utils::core_reexport::num::dec2flt::float">float</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">Helper trait for generic float types.</div></li><li><div class="item-name"><a class="mod" href="lemire/index.html" title="mod pin_utils::core_reexport::num::dec2flt::lemire">lemire</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">Implementation of the Eisel-Lemire algorithm.</div></li><li><div class="item-name"><a class="mod" href="number/index.html" title="mod pin_utils::core_reexport::num::dec2flt::number">number</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">Representation of a float as the significant digits and exponent.</div></li><li><div class="item-name"><a class="mod" href="parse/index.html" title="mod pin_utils::core_reexport::num::dec2flt::parse">parse</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">Functions to parse floating-point numbers.</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.ParseFloatError.html" title="struct pin_utils::core_reexport::num::dec2flt::ParseFloatError">ParseFloatError</a></div><div class="desc docblock-short">An error which can be returned when parsing a float.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.dec2flt.html" title="fn pin_utils::core_reexport::num::dec2flt::dec2flt">dec2flt</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">Converts a decimal string into a floating point number.</div></li><li><div class="item-name"><a class="fn" href="fn.pfe_invalid.html" title="fn pin_utils::core_reexport::num::dec2flt::pfe_invalid">pfe_invalid</a><span class="stab unstable" title="">Experimental</span></div></li></ul></section></div></main></body></html>