#![allow(non_snake_case)]

use bytes::{BufMut, Bytes, BytesMut};

use fdb::database::FdbDatabase;
use fdb::range::{Range, RangeOptions};
use fdb::subspace::Subspace;
use fdb::transaction::{ReadTransaction, Transaction};
use fdb::{Key, KeySelector, Value};

use fdb_rl::range::{KeyHighEndpoint, KeyLowEndpoint, KeyRange};
use fdb_rl::test::cursor::key_value_cursor::{
    key_value_continuation_v0_begin_marker_bytes, key_value_continuation_v0_continuation_bytes,
    key_value_continuation_v0_end_marker_bytes, key_value_cursor_builder_build_range,
};

use libtest_mimic::{Arguments, Failed, Trial};

use tokio::runtime::Builder;
use tokio_stream::StreamExt;

use std::env;
use std::error::Error;

static mut FDB_DATABASE: Option<FdbDatabase> = None;

fn main() -> Result<(), Box<dyn Error>> {
    let args = Arguments::from_args();

    // By default `libthread_mimic` uses a threadpool to run the
    // tests. We are not running the tests in a threadpool.
    //
    // In the main thread we are creating a Tokio current_thread
    // runtime to run the test. This allows us to see the output of
    // the tests in the order that is in the source code.
    //
    // If you want to use a threadpool, then comment the following
    // line.
    let args = {
        let mut args = args;
        args.test_threads = Some(1);
        args
    };

    let fdb_cluster_file = env::var("FDB_CLUSTER_FILE").expect("FDB_CLUSTER_FILE not defined!");

    unsafe {
        fdb::select_api_version(fdb::FDB_API_VERSION as i32);
        fdb::start_network();
    }

    let fdb_database = fdb::open_database(fdb_cluster_file)?;

    unsafe {
        FDB_DATABASE = Some(fdb_database);
    }

    setup_no_subspace()?;

    let tests = vec![
        Trial::test(
            "no_subspace_start_end_forward",
            no_subspace_start_end_forward,
        ),
        Trial::test(
            "no_subspace_start_end_reverse",
            no_subspace_start_end_reverse,
        ),
        Trial::test(
            "no_subspace_start_end_forward_begin_marker",
            no_subspace_start_end_forward_begin_marker,
        ),
        Trial::test(
            "no_subspace_start_end_reverse_begin_marker",
            no_subspace_start_end_reverse_begin_marker,
        ),
        Trial::test(
            "no_subspace_start_end_forward_end_marker",
            no_subspace_start_end_forward_end_marker,
        ),
        Trial::test(
            "no_subspace_start_end_reverse_end_marker",
            no_subspace_start_end_reverse_end_marker,
        ),
        Trial::test(
            "no_subspace_start_end_forward_continuation_first",
            no_subspace_start_end_forward_continuation_first,
        ),
        Trial::test(
            "no_subspace_start_end_reverse_continuation_first",
            no_subspace_start_end_reverse_continuation_first,
        ),
        Trial::test(
            "no_subspace_start_end_forward_continuation_last",
            no_subspace_start_end_forward_continuation_last,
        ),
        Trial::test(
            "no_subspace_start_end_reverse_continuation_last",
            no_subspace_start_end_reverse_continuation_last,
        ),
        Trial::test(
            "no_subspace_start_end_forward_continuation_middle",
            no_subspace_start_end_forward_continuation_middle,
        ),
        Trial::test(
            "no_subspace_start_end_reverse_continuation_middle",
            no_subspace_start_end_reverse_continuation_middle,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_empty_forward",
            no_subspace_inclusive_inclusive_empty_forward,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_empty_reverse",
            no_subspace_inclusive_inclusive_empty_reverse,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_empty_forward_begin_marker",
            no_subspace_inclusive_inclusive_empty_forward_begin_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_empty_reverse_begin_marker",
            no_subspace_inclusive_inclusive_empty_reverse_begin_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_empty_forward_end_marker",
            no_subspace_inclusive_inclusive_empty_forward_end_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_empty_reverse_end_marker",
            no_subspace_inclusive_inclusive_empty_reverse_end_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_one_forward",
            no_subspace_inclusive_inclusive_one_forward,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_one_reverse",
            no_subspace_inclusive_inclusive_one_reverse,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_one_forward_begin_marker",
            no_subspace_inclusive_inclusive_one_forward_begin_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_one_reverse_begin_marker",
            no_subspace_inclusive_inclusive_one_reverse_begin_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_one_forward_end_marker",
            no_subspace_inclusive_inclusive_one_forward_end_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_one_reverse_end_marker",
            no_subspace_inclusive_inclusive_one_reverse_end_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_one_forward_continuation_first",
            no_subspace_inclusive_inclusive_one_forward_continuation_first,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_one_reverse_continuation_first",
            no_subspace_inclusive_inclusive_one_reverse_continuation_first,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_two_forward",
            no_subspace_inclusive_inclusive_two_forward,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_two_reverse",
            no_subspace_inclusive_inclusive_two_reverse,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_two_forward_begin_marker",
            no_subspace_inclusive_inclusive_two_forward_begin_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_two_reverse_begin_marker",
            no_subspace_inclusive_inclusive_two_reverse_begin_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_two_forward_end_marker",
            no_subspace_inclusive_inclusive_two_forward_end_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_two_reverse_end_marker",
            no_subspace_inclusive_inclusive_two_reverse_end_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_two_forward_continuation_first",
            no_subspace_inclusive_inclusive_two_forward_continuation_first,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_two_reverse_continuation_first",
            no_subspace_inclusive_inclusive_two_reverse_continuation_first,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_two_forward_continuation_last",
            no_subspace_inclusive_inclusive_two_forward_continuation_last,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_two_reverse_continuation_last",
            no_subspace_inclusive_inclusive_two_reverse_continuation_last,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_three_forward",
            no_subspace_inclusive_inclusive_three_forward,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_three_reverse",
            no_subspace_inclusive_inclusive_three_reverse,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_three_forward_begin_marker",
            no_subspace_inclusive_inclusive_three_forward_begin_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_three_reverse_begin_marker",
            no_subspace_inclusive_inclusive_three_reverse_begin_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_three_forward_end_marker",
            no_subspace_inclusive_inclusive_three_forward_end_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_three_reverse_end_marker",
            no_subspace_inclusive_inclusive_three_reverse_end_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_three_forward_continuation_first",
            no_subspace_inclusive_inclusive_three_forward_continuation_first,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_three_reverse_continuation_first",
            no_subspace_inclusive_inclusive_three_reverse_continuation_first,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_three_forward_continuation_last",
            no_subspace_inclusive_inclusive_three_forward_continuation_last,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_three_reverse_continuation_last",
            no_subspace_inclusive_inclusive_three_reverse_continuation_last,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_three_forward_continuation_middle",
            no_subspace_inclusive_inclusive_three_forward_continuation_middle,
        ),
        Trial::test(
            "no_subspace_inclusive_inclusive_three_reverse_continuation_middle",
            no_subspace_inclusive_inclusive_three_reverse_continuation_middle,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_empty_forward",
            no_subspace_inclusive_exclusive_empty_forward,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_empty_reverse",
            no_subspace_inclusive_exclusive_empty_reverse,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_empty_forward_begin_marker",
            no_subspace_inclusive_exclusive_empty_forward_begin_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_empty_reverse_begin_marker",
            no_subspace_inclusive_exclusive_empty_reverse_begin_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_empty_forward_end_marker",
            no_subspace_inclusive_exclusive_empty_forward_end_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_empty_reverse_end_marker",
            no_subspace_inclusive_exclusive_empty_reverse_end_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_one_forward",
            no_subspace_inclusive_exclusive_one_forward,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_one_reverse",
            no_subspace_inclusive_exclusive_one_reverse,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_one_forward_begin_marker",
            no_subspace_inclusive_exclusive_one_forward_begin_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_one_reverse_begin_marker",
            no_subspace_inclusive_exclusive_one_reverse_begin_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_one_forward_end_marker",
            no_subspace_inclusive_exclusive_one_forward_end_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_one_reverse_end_marker",
            no_subspace_inclusive_exclusive_one_reverse_end_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_one_forward_continuation_first",
            no_subspace_inclusive_exclusive_one_forward_continuation_first,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_one_reverse_continuation_first",
            no_subspace_inclusive_exclusive_one_reverse_continuation_first,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_two_forward",
            no_subspace_inclusive_exclusive_two_forward,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_two_reverse",
            no_subspace_inclusive_exclusive_two_reverse,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_two_forward_begin_marker",
            no_subspace_inclusive_exclusive_two_forward_begin_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_two_reverse_begin_marker",
            no_subspace_inclusive_exclusive_two_reverse_begin_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_two_forward_end_marker",
            no_subspace_inclusive_exclusive_two_forward_end_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_two_reverse_end_marker",
            no_subspace_inclusive_exclusive_two_reverse_end_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_two_forward_continuation_first",
            no_subspace_inclusive_exclusive_two_forward_continuation_first,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_two_reverse_continuation_first",
            no_subspace_inclusive_exclusive_two_reverse_continuation_first,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_two_forward_continuation_last",
            no_subspace_inclusive_exclusive_two_forward_continuation_last,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_two_reverse_continuation_last",
            no_subspace_inclusive_exclusive_two_reverse_continuation_last,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_three_forward",
            no_subspace_inclusive_exclusive_three_forward,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_three_reverse",
            no_subspace_inclusive_exclusive_three_reverse,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_three_forward_begin_marker",
            no_subspace_inclusive_exclusive_three_forward_begin_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_three_reverse_begin_marker",
            no_subspace_inclusive_exclusive_three_reverse_begin_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_three_forward_end_marker",
            no_subspace_inclusive_exclusive_three_forward_end_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_three_reverse_end_marker",
            no_subspace_inclusive_exclusive_three_reverse_end_marker,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_three_forward_continuation_first",
            no_subspace_inclusive_exclusive_three_forward_continuation_first,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_three_reverse_continuation_first",
            no_subspace_inclusive_exclusive_three_reverse_continuation_first,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_three_forward_continuation_last",
            no_subspace_inclusive_exclusive_three_forward_continuation_last,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_three_reverse_continuation_last",
            no_subspace_inclusive_exclusive_three_reverse_continuation_last,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_three_forward_continuation_middle",
            no_subspace_inclusive_exclusive_three_forward_continuation_middle,
        ),
        Trial::test(
            "no_subspace_inclusive_exclusive_three_reverse_continuation_middle",
            no_subspace_inclusive_exclusive_three_reverse_continuation_middle,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_empty_forward",
            no_subspace_exclusive_inclusive_empty_forward,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_empty_reverse",
            no_subspace_exclusive_inclusive_empty_reverse,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_empty_forward_begin_marker",
            no_subspace_exclusive_inclusive_empty_forward_begin_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_empty_reverse_begin_marker",
            no_subspace_exclusive_inclusive_empty_reverse_begin_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_empty_forward_end_marker",
            no_subspace_exclusive_inclusive_empty_forward_end_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_empty_reverse_end_marker",
            no_subspace_exclusive_inclusive_empty_reverse_end_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_one_forward",
            no_subspace_exclusive_inclusive_one_forward,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_one_reverse",
            no_subspace_exclusive_inclusive_one_reverse,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_one_forward_begin_marker",
            no_subspace_exclusive_inclusive_one_forward_begin_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_one_reverse_begin_marker",
            no_subspace_exclusive_inclusive_one_reverse_begin_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_one_forward_end_marker",
            no_subspace_exclusive_inclusive_one_forward_end_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_one_reverse_end_marker",
            no_subspace_exclusive_inclusive_one_reverse_end_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_one_forward_continuation_first",
            no_subspace_exclusive_inclusive_one_forward_continuation_first,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_one_reverse_continuation_first",
            no_subspace_exclusive_inclusive_one_reverse_continuation_first,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_two_forward",
            no_subspace_exclusive_inclusive_two_forward,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_two_reverse",
            no_subspace_exclusive_inclusive_two_reverse,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_two_forward_begin_marker",
            no_subspace_exclusive_inclusive_two_forward_begin_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_two_reverse_begin_marker",
            no_subspace_exclusive_inclusive_two_reverse_begin_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_two_forward_end_marker",
            no_subspace_exclusive_inclusive_two_forward_end_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_two_reverse_end_marker",
            no_subspace_exclusive_inclusive_two_reverse_end_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_two_forward_continuation_first",
            no_subspace_exclusive_inclusive_two_forward_continuation_first,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_two_reverse_continuation_first",
            no_subspace_exclusive_inclusive_two_reverse_continuation_first,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_two_forward_continuation_last",
            no_subspace_exclusive_inclusive_two_forward_continuation_last,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_two_reverse_continuation_last",
            no_subspace_exclusive_inclusive_two_reverse_continuation_last,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_three_forward",
            no_subspace_exclusive_inclusive_three_forward,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_three_reverse",
            no_subspace_exclusive_inclusive_three_reverse,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_three_forward_begin_marker",
            no_subspace_exclusive_inclusive_three_forward_begin_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_three_reverse_begin_marker",
            no_subspace_exclusive_inclusive_three_reverse_begin_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_three_forward_end_marker",
            no_subspace_exclusive_inclusive_three_forward_end_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_three_reverse_end_marker",
            no_subspace_exclusive_inclusive_three_reverse_end_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_three_forward_continuation_first",
            no_subspace_exclusive_inclusive_three_forward_continuation_first,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_three_reverse_continuation_first",
            no_subspace_exclusive_inclusive_three_reverse_continuation_first,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_three_forward_continuation_last",
            no_subspace_exclusive_inclusive_three_forward_continuation_last,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_three_reverse_continuation_last",
            no_subspace_exclusive_inclusive_three_reverse_continuation_last,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_three_forward_continuation_middle",
            no_subspace_exclusive_inclusive_three_forward_continuation_middle,
        ),
        Trial::test(
            "no_subspace_exclusive_inclusive_three_reverse_continuation_middle",
            no_subspace_exclusive_inclusive_three_reverse_continuation_middle,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_empty_forward",
            no_subspace_exclusive_exclusive_empty_forward,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_empty_reverse",
            no_subspace_exclusive_exclusive_empty_reverse,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_empty_forward_begin_marker",
            no_subspace_exclusive_exclusive_empty_forward_begin_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_empty_reverse_begin_marker",
            no_subspace_exclusive_exclusive_empty_reverse_begin_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_empty_forward_end_marker",
            no_subspace_exclusive_exclusive_empty_forward_end_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_empty_reverse_end_marker",
            no_subspace_exclusive_exclusive_empty_reverse_end_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_one_forward",
            no_subspace_exclusive_exclusive_one_forward,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_one_reverse",
            no_subspace_exclusive_exclusive_one_reverse,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_one_forward_begin_marker",
            no_subspace_exclusive_exclusive_one_forward_begin_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_one_reverse_begin_marker",
            no_subspace_exclusive_exclusive_one_reverse_begin_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_one_forward_end_marker",
            no_subspace_exclusive_exclusive_one_forward_end_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_one_reverse_end_marker",
            no_subspace_exclusive_exclusive_one_reverse_end_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_one_forward_continuation_first",
            no_subspace_exclusive_exclusive_one_forward_continuation_first,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_one_reverse_continuation_first",
            no_subspace_exclusive_exclusive_one_reverse_continuation_first,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_two_forward",
            no_subspace_exclusive_exclusive_two_forward,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_two_reverse",
            no_subspace_exclusive_exclusive_two_reverse,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_two_forward_begin_marker",
            no_subspace_exclusive_exclusive_two_forward_begin_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_two_reverse_begin_marker",
            no_subspace_exclusive_exclusive_two_reverse_begin_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_two_forward_end_marker",
            no_subspace_exclusive_exclusive_two_forward_end_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_two_reverse_end_marker",
            no_subspace_exclusive_exclusive_two_reverse_end_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_two_forward_continuation_first",
            no_subspace_exclusive_exclusive_two_forward_continuation_first,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_two_reverse_continuation_first",
            no_subspace_exclusive_exclusive_two_reverse_continuation_first,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_two_forward_continuation_last",
            no_subspace_exclusive_exclusive_two_forward_continuation_last,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_two_reverse_continuation_last",
            no_subspace_exclusive_exclusive_two_reverse_continuation_last,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_three_forward",
            no_subspace_exclusive_exclusive_three_forward,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_three_reverse",
            no_subspace_exclusive_exclusive_three_reverse,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_three_forward_begin_marker",
            no_subspace_exclusive_exclusive_three_forward_begin_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_three_reverse_begin_marker",
            no_subspace_exclusive_exclusive_three_reverse_begin_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_three_forward_end_marker",
            no_subspace_exclusive_exclusive_three_forward_end_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_three_reverse_end_marker",
            no_subspace_exclusive_exclusive_three_reverse_end_marker,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_three_forward_continuation_first",
            no_subspace_exclusive_exclusive_three_forward_continuation_first,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_three_reverse_continuation_first",
            no_subspace_exclusive_exclusive_three_reverse_continuation_first,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_three_forward_continuation_last",
            no_subspace_exclusive_exclusive_three_forward_continuation_last,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_three_reverse_continuation_last",
            no_subspace_exclusive_exclusive_three_reverse_continuation_last,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_three_forward_continuation_middle",
            no_subspace_exclusive_exclusive_three_forward_continuation_middle,
        ),
        Trial::test(
            "no_subspace_exclusive_exclusive_three_reverse_continuation_middle",
            no_subspace_exclusive_exclusive_three_reverse_continuation_middle,
        ),
    ];

    let _ = libtest_mimic::run(&args, tests);

    setup_subspace()?;

    let tests = vec![
        Trial::test(
            "subspace_global_start_end_forward",
            subspace_global_start_end_forward,
        ),
        Trial::test(
            "subspace_global_start_end_reverse",
            subspace_global_start_end_reverse,
        ),
        Trial::test("subspace_start_end_forward", subspace_start_end_forward),
        Trial::test("subspace_start_end_reverse", subspace_start_end_reverse),
        Trial::test(
            "subspace_start_end_forward_begin_marker",
            subspace_start_end_forward_begin_marker,
        ),
        Trial::test(
            "subspace_start_end_reverse_begin_marker",
            subspace_start_end_reverse_begin_marker,
        ),
        Trial::test(
            "subspace_start_end_forward_end_marker",
            subspace_start_end_forward_end_marker,
        ),
        Trial::test(
            "subspace_start_end_reverse_end_marker",
            subspace_start_end_reverse_end_marker,
        ),
        Trial::test(
            "subspace_start_end_forward_continuation_first",
            subspace_start_end_forward_continuation_first,
        ),
        Trial::test(
            "subspace_start_end_reverse_continuation_first",
            subspace_start_end_reverse_continuation_first,
        ),
        Trial::test(
            "subspace_start_end_forward_continuation_last",
            subspace_start_end_forward_continuation_last,
        ),
        Trial::test(
            "subspace_start_end_reverse_continuation_last",
            subspace_start_end_reverse_continuation_last,
        ),
        Trial::test(
            "subspace_start_end_forward_continuation_middle",
            subspace_start_end_forward_continuation_middle,
        ),
        Trial::test(
            "subspace_start_end_reverse_continuation_middle",
            subspace_start_end_reverse_continuation_middle,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_empty_forward",
            subspace_inclusive_inclusive_empty_forward,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_empty_reverse",
            subspace_inclusive_inclusive_empty_reverse,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_empty_forward_begin_marker",
            subspace_inclusive_inclusive_empty_forward_begin_marker,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_empty_reverse_begin_marker",
            subspace_inclusive_inclusive_empty_reverse_begin_marker,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_empty_forward_end_marker",
            subspace_inclusive_inclusive_empty_forward_end_marker,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_empty_reverse_end_marker",
            subspace_inclusive_inclusive_empty_reverse_end_marker,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_one_forward",
            subspace_inclusive_inclusive_one_forward,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_one_reverse",
            subspace_inclusive_inclusive_one_reverse,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_one_forward_begin_marker",
            subspace_inclusive_inclusive_one_forward_begin_marker,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_one_reverse_begin_marker",
            subspace_inclusive_inclusive_one_reverse_begin_marker,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_one_forward_end_marker",
            subspace_inclusive_inclusive_one_forward_end_marker,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_one_reverse_end_marker",
            subspace_inclusive_inclusive_one_reverse_end_marker,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_one_forward_continuation_first",
            subspace_inclusive_inclusive_one_forward_continuation_first,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_one_reverse_continuation_first",
            subspace_inclusive_inclusive_one_reverse_continuation_first,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_two_forward",
            subspace_inclusive_inclusive_two_forward,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_two_reverse",
            subspace_inclusive_inclusive_two_reverse,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_two_forward_begin_marker",
            subspace_inclusive_inclusive_two_forward_begin_marker,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_two_reverse_begin_marker",
            subspace_inclusive_inclusive_two_reverse_begin_marker,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_two_forward_end_marker",
            subspace_inclusive_inclusive_two_forward_end_marker,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_two_reverse_end_marker",
            subspace_inclusive_inclusive_two_reverse_end_marker,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_two_forward_continuation_first",
            subspace_inclusive_inclusive_two_forward_continuation_first,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_two_reverse_continuation_first",
            subspace_inclusive_inclusive_two_reverse_continuation_first,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_two_forward_continuation_last",
            subspace_inclusive_inclusive_two_forward_continuation_last,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_two_reverse_continuation_last",
            subspace_inclusive_inclusive_two_reverse_continuation_last,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_three_forward",
            subspace_inclusive_inclusive_three_forward,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_three_reverse",
            subspace_inclusive_inclusive_three_reverse,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_three_forward_begin_marker",
            subspace_inclusive_inclusive_three_forward_begin_marker,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_three_reverse_begin_marker",
            subspace_inclusive_inclusive_three_reverse_begin_marker,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_three_forward_end_marker",
            subspace_inclusive_inclusive_three_forward_end_marker,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_three_reverse_end_marker",
            subspace_inclusive_inclusive_three_reverse_end_marker,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_three_forward_continuation_first",
            subspace_inclusive_inclusive_three_forward_continuation_first,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_three_reverse_continuation_first",
            subspace_inclusive_inclusive_three_reverse_continuation_first,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_three_forward_continuation_last",
            subspace_inclusive_inclusive_three_forward_continuation_last,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_three_reverse_continuation_last",
            subspace_inclusive_inclusive_three_reverse_continuation_last,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_three_forward_continuation_middle",
            subspace_inclusive_inclusive_three_forward_continuation_middle,
        ),
        Trial::test(
            "subspace_inclusive_inclusive_three_reverse_continuation_middle",
            subspace_inclusive_inclusive_three_reverse_continuation_middle,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_empty_forward",
            subspace_inclusive_exclusive_empty_forward,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_empty_reverse",
            subspace_inclusive_exclusive_empty_reverse,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_empty_forward_begin_marker",
            subspace_inclusive_exclusive_empty_forward_begin_marker,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_empty_reverse_begin_marker",
            subspace_inclusive_exclusive_empty_reverse_begin_marker,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_empty_forward_end_marker",
            subspace_inclusive_exclusive_empty_forward_end_marker,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_empty_reverse_end_marker",
            subspace_inclusive_exclusive_empty_reverse_end_marker,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_one_forward",
            subspace_inclusive_exclusive_one_forward,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_one_reverse",
            subspace_inclusive_exclusive_one_reverse,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_one_forward_begin_marker",
            subspace_inclusive_exclusive_one_forward_begin_marker,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_one_reverse_begin_marker",
            subspace_inclusive_exclusive_one_reverse_begin_marker,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_one_forward_end_marker",
            subspace_inclusive_exclusive_one_forward_end_marker,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_one_reverse_end_marker",
            subspace_inclusive_exclusive_one_reverse_end_marker,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_one_forward_continuation_first",
            subspace_inclusive_exclusive_one_forward_continuation_first,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_one_reverse_continuation_first",
            subspace_inclusive_exclusive_one_reverse_continuation_first,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_two_forward",
            subspace_inclusive_exclusive_two_forward,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_two_reverse",
            subspace_inclusive_exclusive_two_reverse,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_two_forward_begin_marker",
            subspace_inclusive_exclusive_two_forward_begin_marker,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_two_reverse_begin_marker",
            subspace_inclusive_exclusive_two_reverse_begin_marker,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_two_forward_end_marker",
            subspace_inclusive_exclusive_two_forward_end_marker,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_two_reverse_end_marker",
            subspace_inclusive_exclusive_two_reverse_end_marker,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_two_forward_continuation_first",
            subspace_inclusive_exclusive_two_forward_continuation_first,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_two_reverse_continuation_first",
            subspace_inclusive_exclusive_two_reverse_continuation_first,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_two_forward_continuation_last",
            subspace_inclusive_exclusive_two_forward_continuation_last,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_two_reverse_continuation_last",
            subspace_inclusive_exclusive_two_reverse_continuation_last,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_three_forward",
            subspace_inclusive_exclusive_three_forward,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_three_reverse",
            subspace_inclusive_exclusive_three_reverse,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_three_forward_begin_marker",
            subspace_inclusive_exclusive_three_forward_begin_marker,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_three_reverse_begin_marker",
            subspace_inclusive_exclusive_three_reverse_begin_marker,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_three_forward_end_marker",
            subspace_inclusive_exclusive_three_forward_end_marker,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_three_reverse_end_marker",
            subspace_inclusive_exclusive_three_reverse_end_marker,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_three_forward_continuation_first",
            subspace_inclusive_exclusive_three_forward_continuation_first,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_three_reverse_continuation_first",
            subspace_inclusive_exclusive_three_reverse_continuation_first,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_three_forward_continuation_last",
            subspace_inclusive_exclusive_three_forward_continuation_last,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_three_reverse_continuation_last",
            subspace_inclusive_exclusive_three_reverse_continuation_last,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_three_forward_continuation_middle",
            subspace_inclusive_exclusive_three_forward_continuation_middle,
        ),
        Trial::test(
            "subspace_inclusive_exclusive_three_reverse_continuation_middle",
            subspace_inclusive_exclusive_three_reverse_continuation_middle,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_empty_forward",
            subspace_exclusive_inclusive_empty_forward,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_empty_reverse",
            subspace_exclusive_inclusive_empty_reverse,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_empty_forward_begin_marker",
            subspace_exclusive_inclusive_empty_forward_begin_marker,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_empty_reverse_begin_marker",
            subspace_exclusive_inclusive_empty_reverse_begin_marker,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_empty_forward_end_marker",
            subspace_exclusive_inclusive_empty_forward_end_marker,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_empty_reverse_end_marker",
            subspace_exclusive_inclusive_empty_reverse_end_marker,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_one_forward",
            subspace_exclusive_inclusive_one_forward,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_one_reverse",
            subspace_exclusive_inclusive_one_reverse,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_one_forward_begin_marker",
            subspace_exclusive_inclusive_one_forward_begin_marker,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_one_reverse_begin_marker",
            subspace_exclusive_inclusive_one_reverse_begin_marker,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_one_forward_end_marker",
            subspace_exclusive_inclusive_one_forward_end_marker,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_one_reverse_end_marker",
            subspace_exclusive_inclusive_one_reverse_end_marker,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_one_forward_continuation_first",
            subspace_exclusive_inclusive_one_forward_continuation_first,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_one_reverse_continuation_first",
            subspace_exclusive_inclusive_one_reverse_continuation_first,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_two_forward",
            subspace_exclusive_inclusive_two_forward,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_two_reverse",
            subspace_exclusive_inclusive_two_reverse,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_two_forward_begin_marker",
            subspace_exclusive_inclusive_two_forward_begin_marker,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_two_reverse_begin_marker",
            subspace_exclusive_inclusive_two_reverse_begin_marker,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_two_forward_end_marker",
            subspace_exclusive_inclusive_two_forward_end_marker,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_two_reverse_end_marker",
            subspace_exclusive_inclusive_two_reverse_end_marker,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_two_forward_continuation_first",
            subspace_exclusive_inclusive_two_forward_continuation_first,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_two_reverse_continuation_first",
            subspace_exclusive_inclusive_two_reverse_continuation_first,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_two_forward_continuation_last",
            subspace_exclusive_inclusive_two_forward_continuation_last,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_two_reverse_continuation_last",
            subspace_exclusive_inclusive_two_reverse_continuation_last,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_three_forward",
            subspace_exclusive_inclusive_three_forward,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_three_reverse",
            subspace_exclusive_inclusive_three_reverse,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_three_forward_begin_marker",
            subspace_exclusive_inclusive_three_forward_begin_marker,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_three_reverse_begin_marker",
            subspace_exclusive_inclusive_three_reverse_begin_marker,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_three_forward_end_marker",
            subspace_exclusive_inclusive_three_forward_end_marker,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_three_reverse_end_marker",
            subspace_exclusive_inclusive_three_reverse_end_marker,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_three_forward_continuation_first",
            subspace_exclusive_inclusive_three_forward_continuation_first,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_three_reverse_continuation_first",
            subspace_exclusive_inclusive_three_reverse_continuation_first,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_three_forward_continuation_last",
            subspace_exclusive_inclusive_three_forward_continuation_last,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_three_reverse_continuation_last",
            subspace_exclusive_inclusive_three_reverse_continuation_last,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_three_forward_continuation_middle",
            subspace_exclusive_inclusive_three_forward_continuation_middle,
        ),
        Trial::test(
            "subspace_exclusive_inclusive_three_reverse_continuation_middle",
            subspace_exclusive_inclusive_three_reverse_continuation_middle,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_empty_forward",
            subspace_exclusive_exclusive_empty_forward,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_empty_reverse",
            subspace_exclusive_exclusive_empty_reverse,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_empty_forward_begin_marker",
            subspace_exclusive_exclusive_empty_forward_begin_marker,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_empty_reverse_begin_marker",
            subspace_exclusive_exclusive_empty_reverse_begin_marker,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_empty_forward_end_marker",
            subspace_exclusive_exclusive_empty_forward_end_marker,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_empty_reverse_end_marker",
            subspace_exclusive_exclusive_empty_reverse_end_marker,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_one_forward",
            subspace_exclusive_exclusive_one_forward,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_one_reverse",
            subspace_exclusive_exclusive_one_reverse,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_one_forward_begin_marker",
            subspace_exclusive_exclusive_one_forward_begin_marker,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_one_reverse_begin_marker",
            subspace_exclusive_exclusive_one_reverse_begin_marker,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_one_forward_end_marker",
            subspace_exclusive_exclusive_one_forward_end_marker,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_one_reverse_end_marker",
            subspace_exclusive_exclusive_one_reverse_end_marker,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_one_forward_continuation_first",
            subspace_exclusive_exclusive_one_forward_continuation_first,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_one_reverse_continuation_first",
            subspace_exclusive_exclusive_one_reverse_continuation_first,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_two_forward",
            subspace_exclusive_exclusive_two_forward,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_two_reverse",
            subspace_exclusive_exclusive_two_reverse,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_two_forward_begin_marker",
            subspace_exclusive_exclusive_two_forward_begin_marker,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_two_reverse_begin_marker",
            subspace_exclusive_exclusive_two_reverse_begin_marker,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_two_forward_end_marker",
            subspace_exclusive_exclusive_two_forward_end_marker,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_two_reverse_end_marker",
            subspace_exclusive_exclusive_two_reverse_end_marker,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_two_forward_continuation_first",
            subspace_exclusive_exclusive_two_forward_continuation_first,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_two_reverse_continuation_first",
            subspace_exclusive_exclusive_two_reverse_continuation_first,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_two_forward_continuation_last",
            subspace_exclusive_exclusive_two_forward_continuation_last,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_two_reverse_continuation_last",
            subspace_exclusive_exclusive_two_reverse_continuation_last,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_three_forward",
            subspace_exclusive_exclusive_three_forward,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_three_reverse",
            subspace_exclusive_exclusive_three_reverse,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_three_forward_begin_marker",
            subspace_exclusive_exclusive_three_forward_begin_marker,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_three_reverse_begin_marker",
            subspace_exclusive_exclusive_three_reverse_begin_marker,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_three_forward_end_marker",
            subspace_exclusive_exclusive_three_forward_end_marker,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_three_reverse_end_marker",
            subspace_exclusive_exclusive_three_reverse_end_marker,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_three_forward_continuation_first",
            subspace_exclusive_exclusive_three_forward_continuation_first,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_three_reverse_continuation_first",
            subspace_exclusive_exclusive_three_reverse_continuation_first,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_three_forward_continuation_last",
            subspace_exclusive_exclusive_three_forward_continuation_last,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_three_reverse_continuation_last",
            subspace_exclusive_exclusive_three_reverse_continuation_last,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_three_forward_continuation_middle",
            subspace_exclusive_exclusive_three_forward_continuation_middle,
        ),
        Trial::test(
            "subspace_exclusive_exclusive_three_reverse_continuation_middle",
            subspace_exclusive_exclusive_three_reverse_continuation_middle,
        ),
    ];

    let _ = libtest_mimic::run(&args, tests);

    let fdb_database = unsafe { FDB_DATABASE.take().unwrap() };

    drop(fdb_database);

    unsafe {
        fdb::stop_network();
    }

    Ok(())
}

fn setup_no_subspace() -> Result<(), Box<dyn Error>> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };
    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .run(|tr| async move {
                    // Clear the database.
                    tr.clear_range(Range::new(Bytes::new(), Bytes::from_static(b"\xFF")));

                    for i in 0x00..=0x09 {
                        tr.set(Bytes::from(vec![i]), Bytes::from(format!("value{}", i)));
                    }

                    Ok(())
                })
                .await?;
            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn setup_subspace() -> Result<(), Box<dyn Error>> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };
    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .run(|tr| async move {
                    // Clear the database.
                    tr.clear_range(Range::new(Bytes::new(), Bytes::from_static(b"\xFF")));

                    for (key, value) in vec![
                        (
                            Bytes::from_static(b"\x00"),
                            Bytes::from_static(b"value\x00"),
                        ),
                        (
                            Bytes::from_static(b"\x01"),
                            Bytes::from_static(b"value\x01"),
                        ),
                        (
                            Bytes::from_static(b"subspace"),
                            Bytes::from_static(b"subspace_value"),
                        ),
                    ] {
                        tr.set(key, value);
                    }

                    for i in 0x00..=0x09 {
                        tr.set(
                            {
                                let mut b = BytesMut::new();
                                b.put(Bytes::from_static(b"subspace"));
                                b.put_u8(i);
                                Bytes::from(b)
                            },
                            Bytes::from(format!("subspace_value{}", i)),
                        );
                    }

                    for (key, value) in vec![
                        (
                            Bytes::from_static(b"\xFD"),
                            Bytes::from_static(b"value\xFD"),
                        ),
                        (
                            Bytes::from_static(b"\xFE"),
                            Bytes::from_static(b"value\xFE"),
                        ),
                    ] {
                        tr.set(key, value);
                    }

                    Ok(())
                })
                .await?;
            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

// Tests

fn no_subspace_start_end_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(KeyLowEndpoint::Start, KeyHighEndpoint::End);
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    assert_eq!(range_begin, Key::from(Bytes::new()));
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\xFF")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x00..=0x09 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_start_end_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(KeyLowEndpoint::Start, KeyHighEndpoint::End);
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    assert_eq!(range_begin, Key::from(Bytes::new()));
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\xFF")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x00..=0x09).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_start_end_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(KeyLowEndpoint::Start, KeyHighEndpoint::End);
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    assert_eq!(range_begin, Key::from(Bytes::new()));
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\xFF")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x00..=0x09 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_start_end_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(KeyLowEndpoint::Start, KeyHighEndpoint::End);
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    assert_eq!(range_begin, Key::from(Bytes::new()));
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\xFF")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x00..=0x09).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_start_end_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(KeyLowEndpoint::Start, KeyHighEndpoint::End);
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\xFF")));
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\xFF")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_start_end_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(KeyLowEndpoint::Start, KeyHighEndpoint::End);
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    assert_eq!(range_begin, Key::from(Bytes::new()));
                    assert_eq!(range_end, Key::from(Bytes::new()));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_start_end_forward_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(KeyLowEndpoint::Start, KeyHighEndpoint::End);
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x00")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "\x00".
                    //
                    // The reference key is "\x00\x00". The
                    // intermediate resolved key is going to be
                    // "\x00". Because offset is 1, the final resolved
                    // key would be "\x01".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x00\x00")));

                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\xFF")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x01..=0x09 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_start_end_reverse_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(KeyLowEndpoint::Start, KeyHighEndpoint::End);
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x09")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();

                    assert_eq!(range_begin, Key::from(Bytes::new()));
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x09")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x01..=0x08).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_start_end_forward_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(KeyLowEndpoint::Start, KeyHighEndpoint::End);
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x09")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "\x09".
                    //
                    // The reference key is "\x09\x00". The
                    // intermediate resolved key is going to be
                    // "\x09". Because offset is 1, the final resolved
                    // key would be "\xFF".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x09\x00")));

                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\xFF")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_start_end_reverse_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(KeyLowEndpoint::Start, KeyHighEndpoint::End);
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x00")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    assert_eq!(range_begin, Key::from(Bytes::new()));
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x00")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_start_end_forward_continuation_middle() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(KeyLowEndpoint::Start, KeyHighEndpoint::End);
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "\x05".
                    //
                    // The reference key is "\x05\x00". The
                    // intermediate resolved key is going to be
                    // "\x05". Because offset is 1, the final resolved
                    // key would be "\x06".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05\x00")));

                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\xFF")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x06..=0x09 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_start_end_reverse_continuation_middle() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(KeyLowEndpoint::Start, KeyHighEndpoint::End);
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    assert_eq!(range_begin, Key::from(Bytes::new()));

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    // The end selector final resolved key is
                    // "\x05". However, this end selector final
                    // resolved key is *exclusive*. So, the key we get
                    // when we do the reverse scan would be "\x04".
                    let c = 0x04;

                    for i in (0x00..=c).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_empty_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    // Build an empty
                    // `KeyLowEndpoint::RangeInclusive`,
                    // KeyHighEndpoint::RangeInclusive` range is by
                    // specifying a key that does not exist.
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x10"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x10"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x10", which does not
                    // exist. The intermediate resolved key is going
                    // to be "\x09". Because offset is 1, the final
                    // resolved key would be "\xFF".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x10")));

                    // The reference key is "\x11", which does not
                    // exist. The intermediate resolved key is going
                    // to be "\x09". Because offset is 1, the final
                    // resolved key would be "\xFF".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\xFF", "\xFF"), which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x11")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_empty_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    // Build an empty
                    // `KeyLowEndpoint::RangeInclusive`,
                    // KeyHighEndpoint::RangeInclusive` range is by
                    // specifying a key that does not exist.
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x10"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x10"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x10", which does not
                    // exist. The intermediate resolved key is going
                    // to be "\x09". Because offset is 1, the final
                    // resolved key would be "\xFF".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x10")));

                    // The reference key is "\x11", which does not
                    // exist. The intermediate resolved key is going
                    // to be "\x09". Because offset is 1, the final
                    // resolved key would be "\xFF".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\xFF", "\xFF"), which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x11")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_empty_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    // Build an empty
                    // `KeyLowEndpoint::RangeInclusive`,
                    // KeyHighEndpoint::RangeInclusive` range is by
                    // specifying a key that does not exist.
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x10"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x10"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x10", which does not
                    // exist. The intermediate resolved key is going
                    // to be "\x09". Because offset is 1, the final
                    // resolved key would be "\xFF".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x10")));

                    // The reference key is "\x11", which does not
                    // exist. The intermediate resolved key is going
                    // to be "\x09". Because offset is 1, the final
                    // resolved key would be "\xFF".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\xFF", "\xFF"), which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x11")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_empty_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    // Build an empty
                    // `KeyLowEndpoint::RangeInclusive`,
                    // KeyHighEndpoint::RangeInclusive` range is by
                    // specifying a key that does not exist.
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x10"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x10"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x10", which does not
                    // exist. The intermediate resolved key is going
                    // to be "\x09". Because offset is 1, the final
                    // resolved key would be "\xFF".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x10")));

                    // The reference key is "\x11", which does not
                    // exist. The intermediate resolved key is going
                    // to be "\x09". Because offset is 1, the final
                    // resolved key would be "\xFF".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\xFF", "\xFF"), which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x11")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_empty_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    // Build an empty
                    // `KeyLowEndpoint::RangeInclusive`,
                    // KeyHighEndpoint::RangeInclusive` range is by
                    // specifying a key that does not exist.
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x10"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x10"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x11", which does not
                    // exist. The intermediate resolved key is going
                    // to be "\x09". Because offset is 1, the final
                    // resolved key would be "\xFF".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x11")));

                    // The reference key is "\x11", which does not
                    // exist. The intermediate resolved key is going
                    // to be "\x09". Because offset is 1, the final
                    // resolved key would be "\xFF".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\xFF", "\xFF"), which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x11")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_empty_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    // Build an empty
                    // `KeyLowEndpoint::RangeInclusive`,
                    // KeyHighEndpoint::RangeInclusive` range is by
                    // specifying a key that does not exist.
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x10"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x10"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x10", which does not
                    // exist. The intermediate resolved key is going
                    // to be "\x09". Because offset is 1, the final
                    // resolved key would be "\xFF".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x10")));

                    // The reference key is "\x10", which does not
                    // exist. The intermediate resolved key is going
                    // to be "\x09". Because offset is 1, the final
                    // resolved key would be "\xFF".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\xFF", "\xFF"), which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x10")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_one_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..=0x05 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_one_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x05).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_one_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..=0x05 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_one_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x05).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_one_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x06")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x06", "\x06"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_one_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x05"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_one_forward_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "\x05".
                    //
                    // The reference key is "\x05\x00". The
                    // intermediate resolved key is going to be
                    // "\x05". Because offset is 1, the final resolved
                    // key would be "\x06".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05\x00")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x06", "\x06"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_one_reverse_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x05"), which is an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_two_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..=0x06 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_two_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_two_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..=0x06 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_two_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_two_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x07")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x07", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_two_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x05").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_two_forward_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "\x05".
                    //
                    // The reference key is "\x05\x00". The
                    // intermediate resolved key is going to be
                    // "\x05". Because offset is 1, the final resolved
                    // key would be "\x06".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05\x00")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x06", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x06..=0x06 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_two_reverse_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The
                    // intermediate resolved key is going to be
                    // "\x04". Because offset is 1, the final resolved
                    // key would be "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x05).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_two_forward_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "\x06".
                    //
                    // The reference key is "\x06\x00". The
                    // intermediate resolved key is going to be
                    // "\x06". Because offset is 1, the final resolved
                    // key would be "\x07".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x06\x00")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x07", "\x07"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_two_reverse_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x05"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_three_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..=0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_three_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x07).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_three_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..=0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_three_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x07).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_three_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x08")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x08", "\x08"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_three_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x05"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_three_forward_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "\x05".
                    //
                    // The reference key is "\x05\x00". The
                    // intermediate resolved key is going to be
                    // "\x05". Because offset is 1, the final resolved
                    // key would be "\x06".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05\x00")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x06", "\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x06..=0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_three_reverse_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x07")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The
                    // intermediate resolved key is going to be
                    // "\x04". Because offset is 1, the final resolved
                    // key would be "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_three_forward_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x07")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "\x07".
                    //
                    // The reference key is "\x07\x00". The
                    // intermediate resolved key is going to be
                    // "\x07". Because offset is 1, the final resolved
                    // key would be "\x08".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x07\x00")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x08", "\x08"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_three_reverse_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x05"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_three_forward_continuation_middle() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "\x06".
                    //
                    // The reference key is "\x06\x00". The
                    // intermediate resolved key is going to be
                    // "\x06". Because offset is 1, the final resolved
                    // key would be "\x07".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x06\x00")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x07", "\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x07..=0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_inclusive_three_reverse_continuation_middle() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The
                    // intermediate resolved key is going to be
                    // "\x04". Because offset is 1, the final resolved
                    // key would be "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x05).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_empty_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x03". The intermediate
                    // resolved key is going to be "\x02". Because
                    // offset is 1, the final resolved key would be
                    // "\x03".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x03")));

                    // The reference key is "\x03". The intermediate
                    // resolved key is going to be "\x02". Because
                    // offset is 1, the final resolved key would be
                    // "\x03".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x03", "\x03"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x03")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_empty_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x03". The intermediate
                    // resolved key is going to be "\x02". Because
                    // offset is 1, the final resolved key would be
                    // "\x03".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x03")));

                    // The reference key is "\x03". The intermediate
                    // resolved key is going to be "\x02". Because
                    // offset is 1, the final resolved key would be
                    // "\x03".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x03", "\x03"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x03")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_empty_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x03". The intermediate
                    // resolved key is going to be "\x02". Because
                    // offset is 1, the final resolved key would be
                    // "\x03".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x03")));

                    // The reference key is "\x03". The intermediate
                    // resolved key is going to be "\x02". Because
                    // offset is 1, the final resolved key would be
                    // "\x03".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x03", "\x03"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x03")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_empty_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );

                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x03". The intermediate
                    // resolved key is going to be "\x02". Because
                    // offset is 1, the final resolved key would be
                    // "\x03".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x03")));

                    // The reference key is "\x03". The intermediate
                    // resolved key is going to be "\x02". Because
                    // offset is 1, the final resolved key would be
                    // "\x03".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x03", "\x03"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x03")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_empty_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x03". The intermediate
                    // resolved key is going to be "\x02". Because
                    // offset is 1, the final resolved key would be
                    // "\x03".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x03")));

                    // The reference key is "\x03". The intermediate
                    // resolved key is going to be "\x02". Because
                    // offset is 1, the final resolved key would be
                    // "\x03".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x03", "\x03"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x03")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_empty_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );

                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x03". The intermediate
                    // resolved key is going to be "\x02". Because
                    // offset is 1, the final resolved key would be
                    // "\x03".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x03")));

                    // The reference key is "\x03". The intermediate
                    // resolved key is going to be "\x02". Because
                    // offset is 1, the final resolved key would be
                    // "\x03".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x03", "\x03"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x03")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_one_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..0x06 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_one_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_one_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..0x06 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_one_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_one_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x06")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x06", "\x06"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_one_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x05"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_one_forward_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "\x05".
                    //
                    // The reference key is "\x05\x00". The
                    // intermediate resolved key is going to be
                    // "\x05". Because offset is 1, the final resolved
                    // key would be "\x06".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05\x00")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x06", "\x06"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_one_reverse_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x05"), which is an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_two_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_two_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x07).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_two_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_two_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x07).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_two_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x07")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x07", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_two_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x05").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_two_forward_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "\x05".
                    //
                    // The reference key is "\x05\x00". The
                    // intermediate resolved key is going to be
                    // "\x05". Because offset is 1, the final resolved
                    // key would be "\x06".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05\x00")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x06", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x06..0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_two_reverse_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The
                    // intermediate resolved key is going to be
                    // "\x04". Because offset is 1, the final resolved
                    // key would be "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_two_forward_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "\x06".
                    //
                    // The reference key is "\x06\x00". The
                    // intermediate resolved key is going to be
                    // "\x06". Because offset is 1, the final resolved
                    // key would be "\x07".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x06\x00")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x07", "\x07"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_two_reverse_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x05"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_three_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..0x08 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_three_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x08).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_three_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..0x08 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_three_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x08).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_three_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x08")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x08", "\x08"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_three_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x05"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_three_forward_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "\x05".
                    //
                    // The reference key is "\x05\x00". The
                    // intermediate resolved key is going to be
                    // "\x05". Because offset is 1, the final resolved
                    // key would be "\x06".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05\x00")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x06", "\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x06..0x08 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_three_reverse_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x07")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The
                    // intermediate resolved key is going to be
                    // "\x04". Because offset is 1, the final resolved
                    // key would be "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x07).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_three_forward_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x07")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "\x07".
                    //
                    // The reference key is "\x07\x00". The
                    // intermediate resolved key is going to be
                    // "\x07". Because offset is 1, the final resolved
                    // key would be "\x08".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x07\x00")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x08", "\x08"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_three_reverse_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x05"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_three_forward_continuation_middle() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "\x06".
                    //
                    // The reference key is "\x06\x00". The
                    // intermediate resolved key is going to be
                    // "\x06". Because offset is 1, the final resolved
                    // key would be "\x07".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x06\x00")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x07", "\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x07..0x08 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_inclusive_exclusive_three_reverse_continuation_middle() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The
                    // intermediate resolved key is going to be
                    // "\x04". Because offset is 1, the final resolved
                    // key would be "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_empty_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x04". The intermediate
                    // resolved key is going to be "\x03". Because
                    // offset is 1, the final resolved key would be
                    // "\x04".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x04")));
                    // The reference key is "\x04". The intermediate
                    // resolved key is going to be "\x03". Because
                    // offset is 1, the final resolved key would be
                    // "\x04".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x04", "\x04"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x04")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_empty_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x04". The intermediate
                    // resolved key is going to be "\x03". Because
                    // offset is 1, the final resolved key would be
                    // "\x04".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x04")));

                    // The reference key is "\x04". The intermediate
                    // resolved key is going to be "\x03". Because
                    // offset is 1, the final resolved key would be
                    // "\x04".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x04", "\x04"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x04")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_empty_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x04". The intermediate
                    // resolved key is going to be "\x03". Because
                    // offset is 1, the final resolved key would be
                    // "\x04".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x04")));
                    // The reference key is "\x04". The intermediate
                    // resolved key is going to be "\x03". Because
                    // offset is 1, the final resolved key would be
                    // "\x04".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x04", "\x04"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x04")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_empty_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x04". The intermediate
                    // resolved key is going to be "\x03". Because
                    // offset is 1, the final resolved key would be
                    // "\x04".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x04")));

                    // The reference key is "\x04". The intermediate
                    // resolved key is going to be "\x03". Because
                    // offset is 1, the final resolved key would be
                    // "\x04".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x04", "\x04"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x04")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_empty_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x04". The intermediate
                    // resolved key is going to be "\x03". Because
                    // offset is 1, the final resolved key would be
                    // "\x04".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x04")));
                    // The reference key is "\x04". The intermediate
                    // resolved key is going to be "\x03". Because
                    // offset is 1, the final resolved key would be
                    // "\x04".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x04", "\x04"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x04")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_empty_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x04". The intermediate
                    // resolved key is going to be "\x03". Because
                    // offset is 1, the final resolved key would be
                    // "\x04".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x04")));

                    // The reference key is "\x04". The intermediate
                    // resolved key is going to be "\x03". Because
                    // offset is 1, the final resolved key would be
                    // "\x04".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x04", "\x04"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x04")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_one_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..=0x05 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_one_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x05).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_one_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..=0x05 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_one_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x05).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_one_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x06")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x06", "\x06"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_one_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x05"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_one_forward_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "\x05".
                    //
                    // The reference key is "\x05\x00". The
                    // intermediate resolved key is going to be
                    // "\x05". Because offset is 1, the final resolved
                    // key would be "\x06".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05\x00")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x06", "\x06"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_one_reverse_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x05"), which is an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_two_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..=0x06 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_two_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_two_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..=0x06 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_two_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_two_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x07")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x07", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_two_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x05").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_two_forward_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "\x05".
                    //
                    // The reference key is "\x05\x00". The
                    // intermediate resolved key is going to be
                    // "\x05". Because offset is 1, the final resolved
                    // key would be "\x06".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05\x00")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x06", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x06..=0x06 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_two_reverse_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The
                    // intermediate resolved key is going to be
                    // "\x04". Because offset is 1, the final resolved
                    // key would be "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x05).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_two_forward_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "\x06".
                    //
                    // The reference key is "\x06\x00". The
                    // intermediate resolved key is going to be
                    // "\x06". Because offset is 1, the final resolved
                    // key would be "\x07".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x06\x00")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x07", "\x07"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_two_reverse_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x05"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_three_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..=0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_three_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x07).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_three_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..=0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_three_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x07).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_three_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x08")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x08", "\x08"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_three_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x05"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_three_forward_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "\x05".
                    //
                    // The reference key is "\x05\x00". The
                    // intermediate resolved key is going to be
                    // "\x05". Because offset is 1, the final resolved
                    // key would be "\x06".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05\x00")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x06", "\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x06..=0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_three_reverse_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x07")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The
                    // intermediate resolved key is going to be
                    // "\x04". Because offset is 1, the final resolved
                    // key would be "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_three_forward_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x07")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "\x07".
                    //
                    // The reference key is "\x07\x00". The
                    // intermediate resolved key is going to be
                    // "\x07". Because offset is 1, the final resolved
                    // key would be "\x08".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x07\x00")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x08", "\x08"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_three_reverse_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x05"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_three_forward_continuation_middle() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "\x06".
                    //
                    // The reference key is "\x06\x00". The
                    // intermediate resolved key is going to be
                    // "\x06". Because offset is 1, the final resolved
                    // key would be "\x07".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x06\x00")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x07", "\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x07..=0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_inclusive_three_reverse_continuation_middle() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The
                    // intermediate resolved key is going to be
                    // "\x04". Because offset is 1, the final resolved
                    // key would be "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x05).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_empty_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x04". The intermediate
                    // resolved key is going to be "\x03". Because
                    // offset is 1, the final resolved key would be
                    // "\x04".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x04")));

                    // The reference key is "\x03". The intermediate
                    // resolved key is going to be "\x02". Because
                    // offset is 1, the final resolved key would be
                    // "\x03".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x04", "\x03"), which would be an
                    // empty range, as it is an inverted range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x03")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_empty_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x04". The intermediate
                    // resolved key is going to be "\x03". Because
                    // offset is 1, the final resolved key would be
                    // "\x04".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x04")));

                    // The reference key is "\x03". The intermediate
                    // resolved key is going to be "\x02". Because
                    // offset is 1, the final resolved key would be
                    // "\x03".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x04", "\x03"), which would be an
                    // empty range, as it is an inverted range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x03")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_empty_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x04". The intermediate
                    // resolved key is going to be "\x03". Because
                    // offset is 1, the final resolved key would be
                    // "\x03".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x04")));

                    // The reference key is "\x03". The intermediate
                    // resolved key is going to be "\x02". Because
                    // offset is 1, the final resolved key would be
                    // "\x03".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x04", "\x03"), which would be an
                    // empty range, as it is an inverted range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x03")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_empty_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );

                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x04". The intermediate
                    // resolved key is going to be "\x03". Because
                    // offset is 1, the final resolved key would be
                    // "\x04".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x04")));

                    // The reference key is "\x03". The intermediate
                    // resolved key is going to be "\x02". Because
                    // offset is 1, the final resolved key would be
                    // "\x03".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x04", "\x03"), which would be an
                    // empty range, as it is an inverted range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x03")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_empty_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x03". The intermediate
                    // resolved key is going to be "\x02". Because
                    // offset is 1, the final resolved key would be
                    // "\x03".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x03")));

                    // The reference key is "\x03". The intermediate
                    // resolved key is going to be "\x02". Because
                    // offset is 1, the final resolved key would be
                    // "\x03".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x03", "\x03"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x03")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_empty_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );

                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x04". The intermediate
                    // resolved key is going to be "\x03". Because
                    // offset is 1, the final resolved key would be
                    // "\x04".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x04")));

                    // The reference key is "\x04". The intermediate
                    // resolved key is going to be "\x03". Because
                    // offset is 1, the final resolved key would be
                    // "\x04".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x04", "\x04"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x04")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_one_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..0x06 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_one_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_one_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..0x06 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_one_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_one_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x06")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x06", "\x06"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_one_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x05"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_one_forward_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "\x05".
                    //
                    // The reference key is "\x05\x00". The
                    // intermediate resolved key is going to be
                    // "\x05". Because offset is 1, the final resolved
                    // key would be "\x06".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05\x00")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x06", "\x06"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_one_reverse_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x05"), which is an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_two_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_two_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x07).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_two_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_two_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x07).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_two_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x07")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x07", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_two_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x05").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_two_forward_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "\x05".
                    //
                    // The reference key is "\x05\x00". The
                    // intermediate resolved key is going to be
                    // "\x05". Because offset is 1, the final resolved
                    // key would be "\x06".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05\x00")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x06", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x06..0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_two_reverse_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The
                    // intermediate resolved key is going to be
                    // "\x04". Because offset is 1, the final resolved
                    // key would be "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_two_forward_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "\x06".
                    //
                    // The reference key is "\x06\x00". The
                    // intermediate resolved key is going to be
                    // "\x06". Because offset is 1, the final resolved
                    // key would be "\x07".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x06\x00")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x07", "\x07"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_two_reverse_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x05"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_three_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..0x08 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_three_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x08).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_three_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..0x08 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_three_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x08).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_three_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x08")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x08", "\x08"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_three_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x05"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_three_forward_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "\x05".
                    //
                    // The reference key is "\x05\x00". The
                    // intermediate resolved key is going to be
                    // "\x05". Because offset is 1, the final resolved
                    // key would be "\x06".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05\x00")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x06", "\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x06..0x08 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_three_reverse_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x07")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The
                    // intermediate resolved key is going to be
                    // "\x04". Because offset is 1, the final resolved
                    // key would be "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x07". The intermediate
                    // resolved key is going to be "\x06". Because
                    // offset is 1, the final resolved key would be
                    // "\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x07).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_three_forward_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x07")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "\x07".
                    //
                    // The reference key is "\x07\x00". The
                    // intermediate resolved key is going to be
                    // "\x07". Because offset is 1, the final resolved
                    // key would be "\x08".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x07\x00")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x08", "\x08"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_three_reverse_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x05". The intermediate
                    // resolved key is going to be "\x04". Because
                    // offset is 1, the final resolved key would be
                    // "\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x05"), which is an empty
                    // range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_three_forward_continuation_middle() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "\x06".
                    //
                    // The reference key is "\x06\x00". The
                    // intermediate resolved key is going to be
                    // "\x06". Because offset is 1, the final resolved
                    // key would be "\x07".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x06\x00")));

                    // The reference key is "\x08". The intermediate
                    // resolved key is going to be "\x07". Because
                    // offset is 1, the final resolved key would be
                    // "\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x07", "\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x07..0x08 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn no_subspace_exclusive_exclusive_three_reverse_continuation_middle() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "\x05". The
                    // intermediate resolved key is going to be
                    // "\x04". Because offset is 1, the final resolved
                    // key would be "\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"\x05")));

                    // The reference key is "\x06". The intermediate
                    // resolved key is going to be "\x05". Because
                    // offset is 1, the final resolved key would be
                    // "\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\x05", "\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from(vec![i])));
                        assert_eq!(value, Value::from(Bytes::from(format!("value{}", i))));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_global_start_end_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(KeyLowEndpoint::Start, KeyHighEndpoint::End);
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    assert_eq!(range_begin, Key::from(Bytes::new()));
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\xFF")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for (assert_key, assert_value) in vec![
                        (
                            Key::from(Bytes::from_static(b"\x00")),
                            Value::from(Bytes::from_static(b"value\x00")),
                        ),
                        (
                            Key::from(Bytes::from_static(b"\x01")),
                            Value::from(Bytes::from_static(b"value\x01")),
                        ),
                        (
                            Key::from(Bytes::from_static(b"subspace")),
                            Value::from(Bytes::from_static(b"subspace_value")),
                        ),
                    ] {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, assert_key);
                        assert_eq!(value, assert_value);
                    }

                    for i in 0x00..=0x09 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    for (assert_key, assert_value) in vec![
                        (
                            Key::from(Bytes::from_static(b"\xFD")),
                            Value::from(Bytes::from_static(b"value\xFD")),
                        ),
                        (
                            Key::from(Bytes::from_static(b"\xFE")),
                            Value::from(Bytes::from_static(b"value\xFE")),
                        ),
                    ] {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, assert_key);
                        assert_eq!(value, assert_value);
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_global_start_end_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = None;
                    let key_range = KeyRange::new(KeyLowEndpoint::Start, KeyHighEndpoint::End);
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    assert_eq!(range_begin, Key::from(Bytes::new()));
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"\xFF")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for (assert_key, assert_value) in vec![
                        (
                            Key::from(Bytes::from_static(b"\xFE")),
                            Value::from(Bytes::from_static(b"value\xFE")),
                        ),
                        (
                            Key::from(Bytes::from_static(b"\xFD")),
                            Value::from(Bytes::from_static(b"value\xFD")),
                        ),
                    ] {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, assert_key);
                        assert_eq!(value, assert_value);
                    }

                    for i in (0x00..=0x09).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    for (assert_key, assert_value) in vec![
                        (
                            Key::from(Bytes::from_static(b"subspace")),
                            Value::from(Bytes::from_static(b"subspace_value")),
                        ),
                        (
                            Key::from(Bytes::from_static(b"\x01")),
                            Value::from(Bytes::from_static(b"value\x01")),
                        ),
                        (
                            Key::from(Bytes::from_static(b"\x00")),
                            Value::from(Bytes::from_static(b"value\x00")),
                        ),
                    ] {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, assert_key);
                        assert_eq!(value, assert_value);
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_start_end_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(KeyLowEndpoint::Start, KeyHighEndpoint::End);
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace")));
                    // First key that does not have "subspace" as its
                    // prefix.
                    //
                    // The reference key is "subspacf". The
                    // intermediate resolved key is going to be
                    // "subspace\x09". Because offset is 1, the final
                    // resolved key would be "\xfd"
                    //
                    // The end key selector would be exclusive,
                    // effectively the range would end up begin
                    // `["subspace", "\xFD")`.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspacf")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from_static(b"subspace")));
                        assert_eq!(value, Value::from(Bytes::from_static(b"subspace_value")));
                    }

                    for i in 0x00..=0x09 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_start_end_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(KeyLowEndpoint::Start, KeyHighEndpoint::End);
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace")));
                    // First key that does not have "subspace" as its
                    // prefix.
                    //
                    // The reference key is "subspacf". The
                    // intermediate resolved key is going to be
                    // "subspace\x09". Because offset is 1, the final
                    // resolved key would be "\xFD"
                    //
                    // The end key selector would be exclusive,
                    // effectively the range would end up begin
                    // `["subspace", "\xFD")`.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspacf")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x00..=0x09).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from_static(b"subspace")));
                        assert_eq!(value, Value::from(Bytes::from_static(b"subspace_value")));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_start_end_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(KeyLowEndpoint::Start, KeyHighEndpoint::End);
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace")));
                    // First key that does not have "subspace" as its
                    // prefix.
                    //
                    // The reference key is "subspacf". The
                    // intermediate resolved key is going to be
                    // "subspace\x09". Because offset is 1, the final
                    // resolved key would be "\xFD"
                    //
                    // The end key selector would be
                    // exclusive. Sffectively the range would end up
                    // being `["subspace", "\xFD")`.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspacf")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from_static(b"subspace")));
                        assert_eq!(value, Value::from(Bytes::from_static(b"subspace_value")));
                    }

                    for i in 0x00..=0x09 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_start_end_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(KeyLowEndpoint::Start, KeyHighEndpoint::End);
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace")));
                    // First key that does not have "subspace" as its
                    // prefix.
                    //
                    // The reference key is "subspacf". The
                    // intermediate resolved key is going to be
                    // "subspace\x09". Because offset is 1, the final
                    // resolved key would be "\xFD"
                    //
                    // The end key selector would be exclusive,
                    // effectively the range would end up being
                    // `["subspace", "\xFD")`.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspacf")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x00..=0x09).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from_static(b"subspace")));
                        assert_eq!(value, Value::from(Bytes::from_static(b"subspace_value")));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_start_end_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(KeyLowEndpoint::Start, KeyHighEndpoint::End);
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // First key that does not have "subspace" as its
                    // prefix.
                    //
                    // The reference key is "subspacf". The
                    // intermediate resolved key is going to be
                    // "subspace\x09". Because offset is 1, the final
                    // resolved key would be "\xFD"
                    //
                    // The begin key selector is inclusive, while then
                    // end key selector would be
                    // exclusive. So,effectively the range would end
                    // up being `["\xFD", "\xFD")`, which is an empty
                    // range.
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspacf")));
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspacf")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_start_end_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(KeyLowEndpoint::Start, KeyHighEndpoint::End);
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The begin key selector is inclusive, while then
                    // end key selector would be
                    // exclusive. So,effectively the range would end
                    // up being `["subspace", "subspace")`, which is
                    // an empty range.
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace")));
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_start_end_forward_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(KeyLowEndpoint::Start, KeyHighEndpoint::End);
                    // *Note*: The first continuation here is empty
                    //         byte, which is different when compared
                    //         with no subspace case.
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::new()),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "subspace".
                    //
                    // The reference key is "subspace\x00". The
                    // intermediate resolved key is going to be
                    // "subspace". Because offset is 1, the final resolved
                    // key would be "subspace\x00".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x00")));

                    // First key that does not have "subspace" as its
                    // prefix.
                    //
                    // The reference key is "subspacf". The
                    // intermediate resolved key is going to be
                    // "subspace\x09". Because offset is 1, the final
                    // resolved key would be "\xFD"
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector would be exclusive. So,
                    // effectively the range would end up being
                    // `["subspace\x00", "\xFD")`.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspacf")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x00..=0x09 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_start_end_reverse_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));

                    let key_range = KeyRange::new(KeyLowEndpoint::Start, KeyHighEndpoint::End);
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x09")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();

                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive.
                    //
                    // The range would be `["subspace",
                    // "subspace\x09")`.
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace")));
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x09")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x00..=0x08).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from_static(b"subspace")));
                        assert_eq!(value, Value::from(Bytes::from_static(b"subspace_value")));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_start_end_forward_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(KeyLowEndpoint::Start, KeyHighEndpoint::End);
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x09")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "subspace\x09".
                    //
                    // The reference key is "subspace\x09\x00". The
                    // intermediate resolved key is going to be
                    // "subspace\x09". Because offset is 1, the final
                    // resolved key would be "\xFD".
                    assert_eq!(
                        range_begin,
                        Key::from(Bytes::from_static(b"subspace\x09\x00"))
                    );

                    // First key that does not have "subspace" as its
                    // prefix.
                    //
                    // The reference key is "subspacf". The
                    // intermediate resolved key is going to be
                    // "subspace\x09". Because offset is 1, the final
                    // resolved key would be "\xFD"
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector would be exclusive. So,
                    // effectively the range would end up being
                    // `["xFD", "\xFD")`, which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspacf")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_start_end_reverse_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));

                    let key_range = KeyRange::new(KeyLowEndpoint::Start, KeyHighEndpoint::End);
                    // *Note*: The last continuation here is empty
                    //         byte.
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::new()),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The empty range would be `["subspace",
                    // "subspace")`.
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace")));
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_start_end_forward_continuation_middle() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(KeyLowEndpoint::Start, KeyHighEndpoint::End);
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "subspace\x05".
                    //
                    // The reference key is "subspace\x05\x00". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    assert_eq!(
                        range_begin,
                        Key::from(Bytes::from_static(b"subspace\x05\x00"))
                    );

                    // First key that does not have "subspace" as its
                    // prefix.
                    //
                    // The reference key is "subspacf". The
                    // intermediate resolved key is going to be
                    // "subspace\x09". Because offset is 1, the final
                    // resolved key would be "\xFD"
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector would be exclusive. So,
                    // effectively the range would end up being
                    // `["subspace\x06", "\xFD")`.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspacf")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x06..=0x09 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_start_end_reverse_continuation_middle() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(KeyLowEndpoint::Start, KeyHighEndpoint::End);
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace")));

                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    //
                    // The end key selector would be
                    // exclusive. Effectively the range would end up
                    // being `["subspace", "subspace\x05")`.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x00..=0x04).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        assert_eq!(key, Key::from(Bytes::from_static(b"subspace")));
                        assert_eq!(value, Value::from(Bytes::from_static(b"subspace_value")));
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_empty_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    // Build an empty
                    // `KeyLowEndpoint::RangeInclusive`,
                    // KeyHighEndpoint::RangeInclusive` range is by
                    // specifying a key that does not exist.
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x10"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x10"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x10", which does
                    // not exist. The intermediate resolved key is
                    // going to be "subspace\x09". Because offset is 1, the
                    // final resolved key would be "\xFD".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x10")));

                    // The reference key is "subspace\x11", which does
                    // not exist. The intermediate resolved key is
                    // going to be "subspace\x09". Because offset is 1, the
                    // final resolved key would be "\xFD".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\xFD", "\xFD"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x11")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_empty_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    // Build an empty
                    // `KeyLowEndpoint::RangeInclusive`,
                    // KeyHighEndpoint::RangeInclusive` range is by
                    // specifying a key that does not exist.
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x10"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x10"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x10", which does
                    // not exist. The intermediate resolved key is
                    // going to be "subspace\x09". Because offset is 1, the
                    // final resolved key would be "\xFD".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x10")));

                    // The reference key is "subspace\x11", which does
                    // not exist. The intermediate resolved key is
                    // going to be "subspace\x09". Because offset is 1, the
                    // final resolved key would be "\xFD".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\xFD", "\xFD"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x11")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_empty_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    // Build an empty
                    // `KeyLowEndpoint::RangeInclusive`,
                    // KeyHighEndpoint::RangeInclusive` range is by
                    // specifying a key that does not exist.
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x10"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x10"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x10", which does
                    // not exist. The intermediate resolved key is
                    // going to be "subspace\x09". Because offset is 1, the
                    // final resolved key would be "\xFD".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x10")));

                    // The reference key is "subspace\x11", which does
                    // not exist. The intermediate resolved key is
                    // going to be "subspace\x09". Because offset is 1, the
                    // final resolved key would be "\xFD".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\xFD", "\xFD"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x11")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_empty_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    // Build an empty
                    // `KeyLowEndpoint::RangeInclusive`,
                    // KeyHighEndpoint::RangeInclusive` range is by
                    // specifying a key that does not exist.
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x10"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x10"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x10", which does
                    // not exist. The intermediate resolved key is
                    // going to be "subspace\x09". Because offset is 1, the
                    // final resolved key would be "\xFD".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x10")));

                    // The reference key is "subspace\x11", which does
                    // not exist. The intermediate resolved key is
                    // going to be "subspace\x09". Because offset is 1, the
                    // final resolved key would be "\xFD".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\xFD", "\xFD"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x11")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_empty_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    // Build an empty
                    // `KeyLowEndpoint::RangeInclusive`,
                    // KeyHighEndpoint::RangeInclusive` range is by
                    // specifying a key that does not exist.
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x10"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x10"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x11", which does
                    // not exist. The intermediate resolved key is
                    // going to be "subspace\x09". Because offset is 1, the
                    // final resolved key would be "\xFD".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x11")));

                    // The reference key is "subspace\x11", which does
                    // not exist. The intermediate resolved key is
                    // going to be "subspace\x09". Because offset is 1, the
                    // final resolved key would be "\xFD".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\xFD", "\xFD"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x11")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_empty_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    // Build an empty
                    // `KeyLowEndpoint::RangeInclusive`,
                    // KeyHighEndpoint::RangeInclusive` range is by
                    // specifying a key that does not exist.
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x10"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x10"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x10", which does
                    // not exist. The intermediate resolved key is
                    // going to be "subspace\x09". Because offset is 1, the
                    // final resolved key would be "\xFD".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x10")));

                    // The reference key is "subspace\x10", which does
                    // not exist. The intermediate resolved key is
                    // going to be "subspace\x09". Because offset is 1, the
                    // final resolved key would be "\xFD".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["\xFD", "\xFD"), which would be an
                    // empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x10")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_one_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..=0x05 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_one_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x05).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_one_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..=0x05 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_one_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x05).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_one_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x06")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x06", "subspace\x06"),
                    // which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_one_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x05"),
                    // which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_one_forward_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "subspace\x05".
                    //
                    // The reference key is "subspace\x05\x00". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    assert_eq!(
                        range_begin,
                        Key::from(Bytes::from_static(b"subspace\x05\x00"))
                    );

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x06", "subspace\x06"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_one_reverse_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x05"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_two_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..=0x06 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_two_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_two_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..=0x06 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_two_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_two_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x07")));

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x07", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_two_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x05").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_two_forward_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "subspace\x05\x00".
                    //
                    // The reference key is "subspace\x05\x00". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    assert_eq!(
                        range_begin,
                        Key::from(Bytes::from_static(b"subspace\x05\x00"))
                    );

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x06", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x06..=0x06 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_two_reverse_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x05).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_two_forward_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "subspace\x06".
                    //
                    // The reference key is "subspace\x06\x00". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    assert_eq!(
                        range_begin,
                        Key::from(Bytes::from_static(b"subspace\x06\x00"))
                    );

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x07", "subspace\x07"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_two_reverse_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x05"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_three_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..=0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_three_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x07).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_three_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..=0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_three_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x07).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_three_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x08")));

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x08", "subspace\x08"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_three_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x05"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_three_forward_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "subspace\x05\x00".
                    //
                    // The reference key is "subspace\x05\x00". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    assert_eq!(
                        range_begin,
                        Key::from(Bytes::from_static(b"subspace\x05\x00"))
                    );

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x06", "subspace\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x06..=0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_three_reverse_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x07")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_three_forward_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x07")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "subspace\x07".
                    //
                    // The reference key is "subspace\x07\x00". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    assert_eq!(
                        range_begin,
                        Key::from(Bytes::from_static(b"subspace\x07\x00"))
                    );

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x08", "subspace\x08"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_three_reverse_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x05"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_three_forward_continuation_middle() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "subspace\x06".
                    //
                    // The reference key is "subspace\x06\x00". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    assert_eq!(
                        range_begin,
                        Key::from(Bytes::from_static(b"subspace\x06\x00"))
                    );

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x07", "subspace\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x07..=0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_inclusive_three_reverse_continuation_middle() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x05).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_empty_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x03". The
                    // intermediate resolved key is going to be
                    // "subspace\x02". Because offset is 1, the final
                    // resolved key would be "subspace\x03".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x03")));

                    // The reference key is "subspace\x03". The
                    // intermediate resolved key is going to be
                    // "subspace\x02". Because offset is 1, the final
                    // resolved key would be "subspace\x03".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x03", "subspace\x03"),
                    // which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x03")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_empty_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x03". The
                    // intermediate resolved key is going to be
                    // "subspace\x02". Because offset is 1, the final
                    // resolved key would be "subspace\x03".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x03")));

                    // The reference key is "subspace\x03". The
                    // intermediate resolved key is going to be
                    // "subspace\x02". Because offset is 1, the final
                    // resolved key would be "subspace\x03".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x03", "subspace\x03"),
                    // which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x03")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_empty_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x03". The
                    // intermediate resolved key is going to be
                    // "subspace\x02". Because offset is 1, the final
                    // resolved key would be "subspace\x03".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x03")));

                    // The reference key is "subspace\x03". The
                    // intermediate resolved key is going to be
                    // "subspace\x02". Because offset is 1, the final
                    // resolved key would be "subspace\x03".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x03", "subspace\x03"),
                    // which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x03")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_empty_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );

                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x03". The
                    // intermediate resolved key is going to be
                    // "subspace\x02". Because offset is 1, the final
                    // resolved key would be "subspace\x03".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x03")));

                    // The reference key is "subspace\x03". The
                    // intermediate resolved key is going to be
                    // "subspace\x02". Because offset is 1, the final
                    // resolved key would be "subspace\x03".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x03", "subspace\x03"),
                    // which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x03")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_empty_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x03". The
                    // intermediate resolved key is going to be
                    // "subspace\x02". Because offset is 1, the final
                    // resolved key would be "subspace\x03".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x03")));

                    // The reference key is "subspace\x03". The
                    // intermediate resolved key is going to be
                    // "subspace\x02". Because offset is 1, the final
                    // resolved key would be "subspace\x03".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x03", "subspace\x03"),
                    // which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x03")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_empty_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );

                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x03". The
                    // intermediate resolved key is going to be
                    // "subspace\x02". Because offset is 1, the final
                    // resolved key would be "subspace\x03".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x03")));

                    // The reference key is "subspace\x03". The
                    // intermediate resolved key is going to be
                    // "subspace\x02". Because offset is 1, the final
                    // resolved key would be "subspace\x03".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x03", "subspace\x03"),
                    // which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x03")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_one_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..0x06 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_one_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_one_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..0x06 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_one_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_one_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x06")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x06", "subspace\x06"),
                    // which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_one_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x05"),
                    // which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_one_forward_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "subspace\x05".
                    //
                    // The reference key is "subspace\x05\x00". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    assert_eq!(
                        range_begin,
                        Key::from(Bytes::from_static(b"subspace\x05\x00"))
                    );

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x06", "subspace\x06"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_one_reverse_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x05"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_two_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_two_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x07).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_two_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_two_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x07).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_two_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x07")));

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x07", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_two_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x05").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_two_forward_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "subspace\x05\x00".
                    //
                    // The reference key is "subspace\x05\x00". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    assert_eq!(
                        range_begin,
                        Key::from(Bytes::from_static(b"subspace\x05\x00"))
                    );

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x06", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x06..0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_two_reverse_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_two_forward_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "subspace\x06".
                    //
                    // The reference key is "subspace\x06\x00". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    assert_eq!(
                        range_begin,
                        Key::from(Bytes::from_static(b"subspace\x06\x00"))
                    );

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x07", "subspace\x07"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_two_reverse_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x05"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_three_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..0x08 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_three_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x08).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_three_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..0x08 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_three_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x08).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_three_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x08")));

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x08", "subspace\x08"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_three_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x05"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_three_forward_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "subspace\x05\x00".
                    //
                    // The reference key is "subspace\x05\x00". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    assert_eq!(
                        range_begin,
                        Key::from(Bytes::from_static(b"subspace\x05\x00"))
                    );

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x06", "subspace\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x06..0x08 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_three_reverse_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x07")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x07).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_three_forward_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x07")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "subspace\x07".
                    //
                    // The reference key is "subspace\x07\x00". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    assert_eq!(
                        range_begin,
                        Key::from(Bytes::from_static(b"subspace\x07\x00"))
                    );

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x08", "subspace\x08"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_three_reverse_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x05"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_three_forward_continuation_middle() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "subspace\x06\x00".
                    //
                    // The reference key is "subspace\x06\x00". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    assert_eq!(
                        range_begin,
                        Key::from(Bytes::from_static(b"subspace\x06\x00"))
                    );

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x07", "subspace\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x07..0x08 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_inclusive_exclusive_three_reverse_continuation_middle() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_empty_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x04" The
                    // intermediate resolved key is going to be
                    // "subspace\x03". Because offset is 1, the final
                    // resolved key would be "subspace\x04".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x04")));

                    // The reference key is "subspace\x04" The
                    // intermediate resolved key is going to be
                    // "subspace\x03". Because offset is 1, the final
                    // resolved key would be "subspace\x04".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x04", "subspace\x04"),
                    // which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x04")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_empty_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x04" The
                    // intermediate resolved key is going to be
                    // "subspace\x03". Because offset is 1, the final
                    // resolved key would be "subspace\x04".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x04")));

                    // The reference key is "subspace\x04" The
                    // intermediate resolved key is going to be
                    // "subspace\x03". Because offset is 1, the final
                    // resolved key would be "subspace\x04".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x04", "subspace\x04"),
                    // which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x04")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_empty_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x04" The
                    // intermediate resolved key is going to be
                    // "subspace\x03". Because offset is 1, the final
                    // resolved key would be "subspace\x04".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x04")));

                    // The reference key is "subspace\x04" The
                    // intermediate resolved key is going to be
                    // "subspace\x03". Because offset is 1, the final
                    // resolved key would be "subspace\x04".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x04", "subspace\x04"),
                    // which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x04")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_empty_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x04" The
                    // intermediate resolved key is going to be
                    // "subspace\x03". Because offset is 1, the final
                    // resolved key would be "subspace\x04".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x04")));

                    // The reference key is "subspace\x04" The
                    // intermediate resolved key is going to be
                    // "subspace\x03". Because offset is 1, the final
                    // resolved key would be "subspace\x04".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x04", "subspace\x04"),
                    // which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x04")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_empty_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x04" The
                    // intermediate resolved key is going to be
                    // "subspace\x03". Because offset is 1, the final
                    // resolved key would be "subspace\x04".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x04")));

                    // The reference key is "subspace\x04" The
                    // intermediate resolved key is going to be
                    // "subspace\x03". Because offset is 1, the final
                    // resolved key would be "subspace\x04".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x04", "subspace\x04"),
                    // which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x04")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_empty_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x04" The
                    // intermediate resolved key is going to be
                    // "subspace\x03". Because offset is 1, the final
                    // resolved key would be "subspace\x04".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x04")));

                    // The reference key is "subspace\x04" The
                    // intermediate resolved key is going to be
                    // "subspace\x03". Because offset is 1, the final
                    // resolved key would be "subspace\x04".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x04", "subspace\x04"),
                    // which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x04")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_one_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..=0x05 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_one_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x05).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_one_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..=0x05 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_one_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x05).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_one_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x06")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x06", "subspace\x06"),
                    // which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_one_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x05"),
                    // which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_one_forward_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "subspace\x05".
                    //
                    // The reference key is "subspace\x05\x00". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    assert_eq!(
                        range_begin,
                        Key::from(Bytes::from_static(b"subspace\x05\x00"))
                    );

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x06", "subspace\x06"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_one_reverse_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x05"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x05"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_two_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..=0x06 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_two_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_two_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..=0x06 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_two_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_two_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x07")));

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x07", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_two_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x05").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_two_forward_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "subspace\x05\x00".
                    //
                    // The reference key is "subspace\x05\x00". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    assert_eq!(
                        range_begin,
                        Key::from(Bytes::from_static(b"subspace\x05\x00"))
                    );

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x06", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x06..=0x06 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_two_reverse_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x05).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_two_forward_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "subspace\x06".
                    //
                    // The reference key is "subspace\x06\x00". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    assert_eq!(
                        range_begin,
                        Key::from(Bytes::from_static(b"subspace\x06\x00"))
                    );

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x07", "subspace\x07"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_two_reverse_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x05"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_three_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..=0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_three_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x07).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_three_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..=0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_three_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x07).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_three_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x08")));

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x08", "subspace\x08"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_three_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x05"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_three_forward_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "subspace\x05\x00".
                    //
                    // The reference key is "subspace\x05\x00". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    assert_eq!(
                        range_begin,
                        Key::from(Bytes::from_static(b"subspace\x05\x00"))
                    );

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x06", "subspace\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x06..=0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_three_reverse_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x07")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_three_forward_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x07")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "subspace\x07".
                    //
                    // The reference key is "subspace\x07\x00". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    assert_eq!(
                        range_begin,
                        Key::from(Bytes::from_static(b"subspace\x07\x00"))
                    );

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x08", "subspace\x08"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_three_reverse_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x05"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_three_forward_continuation_middle() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "subspace\x06".
                    //
                    // The reference key is "subspace\x06\x00". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    assert_eq!(
                        range_begin,
                        Key::from(Bytes::from_static(b"subspace\x06\x00"))
                    );

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x07", "subspace\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x07..=0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_inclusive_three_reverse_continuation_middle() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeInclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..=0x05).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_empty_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x04". The
                    // intermediate resolved key is going to be
                    // "subspace\x03". Because offset is 1, the final
                    // resolved key would be "subspace\x04".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x04")));

                    // The reference key is "subspace\x03". The
                    // intermediate resolved key is going to be
                    // "subspace\x02". Because offset is 1, the final
                    // resolved key would be "subspace\x03".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x04", "subspace\x03"),
                    // which would be an empty range, as it is an
                    // inverted range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x03")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_empty_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x04". The
                    // intermediate resolved key is going to be
                    // "subspace\x03". Because offset is 1, the final
                    // resolved key would be "subspace\x04".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x04")));

                    // The reference key is "subspace\x03". The
                    // intermediate resolved key is going to be
                    // "subspace\x02". Because offset is 1, the final
                    // resolved key would be "subspace\x03".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x04", "subspace\x03"),
                    // which would be an empty range, as it is an
                    // inverted range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x03")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_empty_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x04". The
                    // intermediate resolved key is going to be
                    // "subspace\x03". Because offset is 1, the final
                    // resolved key would be "subspace\x04".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x04")));

                    // The reference key is "subspace\x03". The
                    // intermediate resolved key is going to be
                    // "subspace\x02". Because offset is 1, the final
                    // resolved key would be "subspace\x03".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x04", "subspace\x03"),
                    // which would be an empty range, as it is an
                    // inverted range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x03")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_empty_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x04". The
                    // intermediate resolved key is going to be
                    // "subspace\x03". Because offset is 1, the final
                    // resolved key would be "subspace\x04".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x04")));

                    // The reference key is "subspace\x03". The
                    // intermediate resolved key is going to be
                    // "subspace\x02". Because offset is 1, the final
                    // resolved key would be "subspace\x03".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x04", "subspace\x03"),
                    // which would be an empty range, as it is an
                    // inverted range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x03")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_empty_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x03". The
                    // intermediate resolved key is going to be
                    // "subspace\x02". Because offset is 1, the final
                    // resolved key would be "subspace\x03".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x03")));

                    // The reference key is "subspace\x03". The
                    // intermediate resolved key is going to be
                    // "subspace\x02". Because offset is 1, the final
                    // resolved key would be "subspace\x03".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x03", "subspace\x03"),
                    // which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x03")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_empty_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x03"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x04". The
                    // intermediate resolved key is going to be
                    // "subspace\x03". Because offset is 1, the final
                    // resolved key would be "subspace\x04".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x04")));

                    // The reference key is "subspace\x04". The
                    // intermediate resolved key is going to be
                    // "subspace\x03". Because offset is 1, the final
                    // resolved key would be "subspace\x04".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x04", "subspace\x04"),
                    // which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x04")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_one_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..0x06 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_one_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_one_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..0x06 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_one_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_one_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x06")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x06", "subspace\x06"),
                    // which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_one_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();

                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x05"),
                    // which would be an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_one_forward_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "subspace\x05".
                    //
                    // The reference key is "subspace\x05\x00". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    assert_eq!(
                        range_begin,
                        Key::from(Bytes::from_static(b"subspace\x05\x00"))
                    );

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x06", "subspace\x06"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_one_reverse_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x06"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();

                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x05"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_two_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_two_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x07).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_two_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_two_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x07).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_two_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x07")));

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x07", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_two_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x05").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_two_forward_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "subspace\x05\x00".
                    //
                    // The reference key is "subspace\x05\x00". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    assert_eq!(
                        range_begin,
                        Key::from(Bytes::from_static(b"subspace\x05\x00"))
                    );

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x06", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x06..0x07 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_two_reverse_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_two_forward_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "subspace\x06".
                    //
                    // The reference key is "subspace\x06\x00". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    assert_eq!(
                        range_begin,
                        Key::from(Bytes::from_static(b"subspace\x06\x00"))
                    );

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x07", "subspace\x07"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_two_reverse_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x07"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x05"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_three_forward() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = None;
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..0x08 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_three_reverse() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = None;
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x08).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_three_forward_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x05..0x08 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_three_reverse_begin_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_begin_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x08).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_three_forward_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x08")));

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x08", "subspace\x08"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_three_reverse_end_marker() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_end_marker_bytes()?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x05"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_three_forward_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "subspace\x05\x00".
                    //
                    // The reference key is "subspace\x05\x00". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    assert_eq!(
                        range_begin,
                        Key::from(Bytes::from_static(b"subspace\x05\x00"))
                    );

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x06", "subspace\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x06..0x08 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_three_reverse_continuation_first() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x07")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x07". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x07").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x07")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x07).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_three_forward_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x07")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "subspace\x07".
                    //
                    // The reference key is "subspace\x07\x00". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    assert_eq!(
                        range_begin,
                        Key::from(Bytes::from_static(b"subspace\x07\x00"))
                    );

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x08", "subspace\x08"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_three_reverse_continuation_last() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x05")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x05"),
                    // which is an empty range.
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x05")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    let mut kvs = Vec::new();

                    while let Some(x) = range_stream.next().await {
                        kvs.push(x?);
                    }

                    assert_eq!(kvs.len(), 0);

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_three_forward_continuation_middle() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = false;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The key immediately after "subspace\x06\x00".
                    //
                    // The reference key is "subspace\x06\x00". The
                    // intermediate resolved key is going to be
                    // "subspace\x06". Because offset is 1, the final
                    // resolved key would be "subspace\x07".
                    assert_eq!(
                        range_begin,
                        Key::from(Bytes::from_static(b"subspace\x06\x00"))
                    );

                    // The reference key is "subspace\x08". The
                    // intermediate resolved key is going to be
                    // "subspace\x07". Because offset is 1, the final
                    // resolved key would be "subspace\x08".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x07", "subspace\x08").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x08")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in 0x07..0x08 {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}

fn subspace_exclusive_exclusive_three_reverse_continuation_middle() -> Result<(), Failed> {
    let rt = Builder::new_current_thread().build()?;

    let fdb_database_ref = unsafe { FDB_DATABASE.as_ref().unwrap() };

    rt.block_on({
        let fdb_database = fdb_database_ref.clone();
        async move {
            fdb_database
                .read(|tr| async move {
                    let maybe_subspace = Some(Subspace::new(Bytes::from_static(b"subspace")));
                    let key_range = KeyRange::new(
                        KeyLowEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x04"))),
                        KeyHighEndpoint::RangeExclusive(Key::from(Bytes::from_static(b"\x08"))),
                    );
                    let continuation = Some(key_value_continuation_v0_continuation_bytes(
                        Key::from(Bytes::from_static(b"\x06")),
                    )?);
                    let reverse = true;

                    let range = key_value_cursor_builder_build_range(
                        &maybe_subspace,
                        key_range,
                        continuation,
                        reverse,
                    )?;

                    let (range_begin, range_end) = range.clone().into_parts();
                    // The reference key is "subspace\x05". The
                    // intermediate resolved key is going to be
                    // "subspace\x04". Because offset is 1, the final
                    // resolved key would be "subspace\x05".
                    assert_eq!(range_begin, Key::from(Bytes::from_static(b"subspace\x05")));

                    // The reference key is "subspace\x06". The
                    // intermediate resolved key is going to be
                    // "subspace\x05". Because offset is 1, the final
                    // resolved key would be "subspace\x06".
                    //
                    // The begin key selector is inclusive, while the
                    // end key selector is exclusive, so the range
                    // would be ["subspace\x05", "subspace\x06").
                    assert_eq!(range_end, Key::from(Bytes::from_static(b"subspace\x06")));

                    let mut range_options = RangeOptions::default();
                    range_options.set_reverse(reverse);

                    let (range_begin, range_end) = range.into_parts();

                    let mut range_stream = tr.get_range(
                        KeySelector::first_greater_or_equal(range_begin),
                        KeySelector::first_greater_or_equal(range_end),
                        range_options,
                    );

                    for i in (0x05..0x06).rev() {
                        // Safety: If `unwrap()` fails, then its a
                        //         bug.
                        let x = range_stream.next().await.unwrap();

                        let (key, value) = x?.into_parts();
                        let assert_key = Key::from({
                            let mut b = BytesMut::new();
                            b.put(Bytes::from_static(b"subspace"));
                            b.put_u8(i);
                            Bytes::from(b)
                        });
                        assert_eq!(key, assert_key);
                        assert_eq!(
                            value,
                            Value::from(Bytes::from(format!("subspace_value{}", i)))
                        );
                    }

                    Ok(())
                })
                .await?;

            Result::<(), Box<dyn Error>>::Ok(())
        }
    })?;

    Ok(())
}
