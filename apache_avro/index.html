<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A library for working with Apache Avro in Rust."><meta name="keywords" content="rust, rustlang, rust-lang, apache_avro"><title>apache_avro - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-52c5db6f6f352e54.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-4743e13df3dfe8c4.css"><link rel="stylesheet" disabled href="../static.files/dark-0e1b889528bd466b.css"><link rel="stylesheet" disabled href="../static.files/ayu-65289d5d067c7c66.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-3367e395607fafc1.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../apache_avro/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../apache_avro/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate apache_avro</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.14.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">apache_avro</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/apache_avro/lib.rs.html#18-980">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A library for working with <a href="https://avro.apache.org/">Apache Avro</a> in Rust.</p>
<p>Please check our <a href="https://docs.rs/apache-avro">documentation</a> for examples, tutorials and API reference.</p>
<p><strong><a href="https://avro.apache.org/">Apache Avro</a></strong> is a data serialization system which provides rich
data structures and a compact, fast, binary data format.</p>
<p>All data in Avro is schematized, as in the following example:</p>
<div class="example-wrap"><pre class="language-text"><code>{
    &quot;type&quot;: &quot;record&quot;,
    &quot;name&quot;: &quot;test&quot;,
    &quot;fields&quot;: [
        {&quot;name&quot;: &quot;a&quot;, &quot;type&quot;: &quot;long&quot;, &quot;default&quot;: 42},
        {&quot;name&quot;: &quot;b&quot;, &quot;type&quot;: &quot;string&quot;}
    ]
}
</code></pre></div>
<p>There are basically two ways of handling Avro data in Rust:</p>
<ul>
<li><strong>as Avro-specialized data types</strong> based on an Avro schema;</li>
<li><strong>as generic Rust serde-compatible types</strong> implementing/deriving <code>Serialize</code> and
<code>Deserialize</code>;</li>
</ul>
<p><strong>apache-avro</strong> provides a way to read and write both these data representations easily and
efficiently.</p>
<h2 id="installing-the-library"><a href="#installing-the-library">Installing the library</a></h2>
<p>Add to your <code>Cargo.toml</code>:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
apache-avro = &quot;x.y&quot;
</code></pre></div>
<p>Or in case you want to leverage the <strong>Snappy</strong> codec:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies.apache-avro]
version = &quot;x.y&quot;
features = [&quot;snappy&quot;]
</code></pre></div><h2 id="upgrading-to-a-newer-minor-version"><a href="#upgrading-to-a-newer-minor-version">Upgrading to a newer minor version</a></h2>
<p>The library is still in beta, so there might be backward-incompatible changes between minor
versions. If you have troubles upgrading, check the <a href="migration_guide.md">version upgrade guide</a>.</p>
<h2 id="defining-a-schema"><a href="#defining-a-schema">Defining a schema</a></h2>
<p>An Avro data cannot exist without an Avro schema. Schemas <strong>must</strong> be used while writing and
<strong>can</strong> be used while reading and they carry the information regarding the type of data we are
handling. Avro schemas are used for both schema validation and resolution of Avro data.</p>
<p>Avro schemas are defined in <strong>JSON</strong> format and can just be parsed out of a raw string:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>apache_avro::Schema;

<span class="kw">let </span>raw_schema = <span class="string">r#&quot;
    {
        &quot;type&quot;: &quot;record&quot;,
        &quot;name&quot;: &quot;test&quot;,
        &quot;fields&quot;: [
            {&quot;name&quot;: &quot;a&quot;, &quot;type&quot;: &quot;long&quot;, &quot;default&quot;: 42},
            {&quot;name&quot;: &quot;b&quot;, &quot;type&quot;: &quot;string&quot;}
        ]
    }
&quot;#</span>;

<span class="comment">// if the schema is not valid, this function will return an error
</span><span class="kw">let </span>schema = Schema::parse_str(raw_schema).unwrap();

<span class="comment">// schemas can be printed for debugging
</span><span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, schema);</code></pre></div>
<p>Additionally, a list of of definitions (which may depend on each other) can be given and all of
them will be parsed into the corresponding schemas.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>apache_avro::Schema;

<span class="kw">let </span>raw_schema_1 = <span class="string">r#&quot;{
        &quot;name&quot;: &quot;A&quot;,
        &quot;type&quot;: &quot;record&quot;,
        &quot;fields&quot;: [
            {&quot;name&quot;: &quot;field_one&quot;, &quot;type&quot;: &quot;float&quot;}
        ]
    }&quot;#</span>;

<span class="comment">// This definition depends on the definition of A above
</span><span class="kw">let </span>raw_schema_2 = <span class="string">r#&quot;{
        &quot;name&quot;: &quot;B&quot;,
        &quot;type&quot;: &quot;record&quot;,
        &quot;fields&quot;: [
            {&quot;name&quot;: &quot;field_one&quot;, &quot;type&quot;: &quot;A&quot;}
        ]
    }&quot;#</span>;

<span class="comment">// if the schemas are not valid, this function will return an error
</span><span class="kw">let </span>schemas = Schema::parse_list(<span class="kw-2">&amp;</span>[raw_schema_1, raw_schema_2]).unwrap();

<span class="comment">// schemas can be printed for debugging
</span><span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, schemas);</code></pre></div>
<p><em>N.B.</em> It is important to note that the composition of schema definitions requires schemas with names.
For this reason, only schemas of type Record, Enum, and Fixed should be input into this function.</p>
<p>The library provides also a programmatic interface to define schemas without encoding them in
JSON (for advanced use), but we highly recommend the JSON interface. Please read the API
reference in case you are interested.</p>
<p>For more information about schemas and what kind of information you can encapsulate in them,
please refer to the appropriate section of the
<a href="https://avro.apache.org/docs/current/spec.html#schemas">Avro Specification</a>.</p>
<h2 id="writing-data"><a href="#writing-data">Writing data</a></h2>
<p>Once we have defined a schema, we are ready to serialize data in Avro, validating them against
the provided schema in the process. As mentioned before, there are two ways of handling Avro
data in Rust.</p>
<p><strong>NOTE:</strong> The library also provides a low-level interface for encoding a single datum in Avro
bytecode without generating markers and headers (for advanced use), but we highly recommend the
<code>Writer</code> interface to be totally Avro-compatible. Please read the API reference in case you are
interested.</p>
<h3 id="the-avro-way"><a href="#the-avro-way">The avro way</a></h3>
<p>Given that the schema we defined above is that of an Avro <em>Record</em>, we are going to use the
associated type provided by the library to specify the data we want to serialize:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>apache_avro::types::Record;
<span class="kw">use </span>apache_avro::Writer;
<span class="comment">// a writer needs a schema and something to write to
</span><span class="kw">let </span><span class="kw-2">mut </span>writer = Writer::new(<span class="kw-2">&amp;</span>schema, Vec::new());

<span class="comment">// the Record type models our Record schema
</span><span class="kw">let </span><span class="kw-2">mut </span>record = Record::new(writer.schema()).unwrap();
record.put(<span class="string">&quot;a&quot;</span>, <span class="number">27i64</span>);
record.put(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;foo&quot;</span>);

<span class="comment">// schema validation happens here
</span>writer.append(record).unwrap();

<span class="comment">// this is how to get back the resulting avro bytecode
// this performs a flush operation to make sure data has been written, so it can fail
// you can also call `writer.flush()` yourself without consuming the writer
</span><span class="kw">let </span>encoded = writer.into_inner().unwrap();</code></pre></div>
<p>The vast majority of the times, schemas tend to define a record as a top-level container
encapsulating all the values to convert as fields and providing documentation for them, but in
case we want to directly define an Avro value, the library offers that capability via the
<code>Value</code> interface.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>apache_avro::types::Value;

<span class="kw">let </span><span class="kw-2">mut </span>value = Value::String(<span class="string">&quot;foo&quot;</span>.to_string());</code></pre></div>
<h3 id="the-serde-way"><a href="#the-serde-way">The serde way</a></h3>
<p>Given that the schema we defined above is an Avro <em>Record</em>, we can directly use a Rust struct
deriving <code>Serialize</code> to model our data:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>apache_avro::Writer;

<span class="attr">#[derive(Debug, Serialize)]
</span><span class="kw">struct </span>Test {
    a: i64,
    b: String,
}

<span class="comment">// a writer needs a schema and something to write to
</span><span class="kw">let </span><span class="kw-2">mut </span>writer = Writer::new(<span class="kw-2">&amp;</span>schema, Vec::new());

<span class="comment">// the structure models our Record schema
</span><span class="kw">let </span>test = Test {
    a: <span class="number">27</span>,
    b: <span class="string">&quot;foo&quot;</span>.to_owned(),
};

<span class="comment">// schema validation happens here
</span>writer.append_ser(test).unwrap();

<span class="comment">// this is how to get back the resulting avro bytecode
// this performs a flush operation to make sure data is written, so it can fail
// you can also call `writer.flush()` yourself without consuming the writer
</span><span class="kw">let </span>encoded = writer.into_inner();</code></pre></div>
<p>The vast majority of the times, schemas tend to define a record as a top-level container
encapsulating all the values to convert as fields and providing documentation for them, but in
case we want to directly define an Avro value, any type implementing <code>Serialize</code> should work.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>value = <span class="string">&quot;foo&quot;</span>.to_string();</code></pre></div>
<h3 id="using-codecs-to-compress-data"><a href="#using-codecs-to-compress-data">Using codecs to compress data</a></h3>
<p>Avro supports three different compression codecs when encoding data:</p>
<ul>
<li><strong>Null</strong>: leaves data uncompressed;</li>
<li><strong>Deflate</strong>: writes the data block using the deflate algorithm as specified in RFC 1951, and
typically implemented using the zlib library. Note that this format (unlike the “zlib format” in
RFC 1950) does not have a checksum.</li>
<li><strong>Snappy</strong>: uses Google’s <a href="http://google.github.io/snappy/">Snappy</a> compression library. Each
compressed block is followed by the 4-byte, big-endianCRC32 checksum of the uncompressed data in
the block. You must enable the <code>snappy</code> feature to use this codec.</li>
</ul>
<p>To specify a codec to use to compress data, just specify it while creating a <code>Writer</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>apache_avro::Writer;
<span class="kw">use </span>apache_avro::Codec;
<span class="kw">let </span><span class="kw-2">mut </span>writer = Writer::with_codec(<span class="kw-2">&amp;</span>schema, Vec::new(), Codec::Deflate);</code></pre></div>
<h2 id="reading-data"><a href="#reading-data">Reading data</a></h2>
<p>As far as reading Avro encoded data goes, we can just use the schema encoded with the data to
read them. The library will do it automatically for us, as it already does for the compression
codec:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>apache_avro::Reader;
<span class="comment">// reader creation can fail in case the input to read from is not Avro-compatible or malformed
</span><span class="kw">let </span>reader = Reader::new(<span class="kw-2">&amp;</span>input[..]).unwrap();</code></pre></div>
<p>In case, instead, we want to specify a different (but compatible) reader schema from the schema
the data has been written with, we can just do as the following:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>apache_avro::Schema;
<span class="kw">use </span>apache_avro::Reader;

<span class="kw">let </span>reader_raw_schema = <span class="string">r#&quot;
    {
        &quot;type&quot;: &quot;record&quot;,
        &quot;name&quot;: &quot;test&quot;,
        &quot;fields&quot;: [
            {&quot;name&quot;: &quot;a&quot;, &quot;type&quot;: &quot;long&quot;, &quot;default&quot;: 42},
            {&quot;name&quot;: &quot;b&quot;, &quot;type&quot;: &quot;string&quot;},
            {&quot;name&quot;: &quot;c&quot;, &quot;type&quot;: &quot;long&quot;, &quot;default&quot;: 43}
        ]
    }
&quot;#</span>;

<span class="kw">let </span>reader_schema = Schema::parse_str(reader_raw_schema).unwrap();

<span class="comment">// reader creation can fail in case the input to read from is not Avro-compatible or malformed
</span><span class="kw">let </span>reader = Reader::with_schema(<span class="kw-2">&amp;</span>reader_schema, <span class="kw-2">&amp;</span>input[..]).unwrap();</code></pre></div>
<p>The library will also automatically perform schema resolution while reading the data.</p>
<p>For more information about schema compatibility and resolution, please refer to the
<a href="https://avro.apache.org/docs/current/spec.html#schemas">Avro Specification</a>.</p>
<p>As usual, there are two ways to handle Avro data in Rust, as you can see below.</p>
<p><strong>NOTE:</strong> The library also provides a low-level interface for decoding a single datum in Avro
bytecode without markers and header (for advanced use), but we highly recommend the <code>Reader</code>
interface to leverage all Avro features. Please read the API reference in case you are
interested.</p>
<h3 id="the-avro-way-1"><a href="#the-avro-way-1">The avro way</a></h3>
<p>We can just read directly instances of <code>Value</code> out of the <code>Reader</code> iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>apache_avro::Reader;
<span class="kw">let </span>reader = Reader::new(<span class="kw-2">&amp;</span>input[..]).unwrap();

<span class="comment">// value is a Result  of an Avro Value in case the read operation fails
</span><span class="kw">for </span>value <span class="kw">in </span>reader {
    <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, value.unwrap());
}
</code></pre></div>
<h3 id="the-serde-way-1"><a href="#the-serde-way-1">The serde way</a></h3>
<p>Alternatively, we can use a Rust type implementing <code>Deserialize</code> and representing our schema to
read the data into:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>apache_avro::Reader;
<span class="kw">use </span>apache_avro::from_value;

<span class="attr">#[derive(Debug, Deserialize)]
</span><span class="kw">struct </span>Test {
    a: i64,
    b: String,
}

<span class="kw">let </span>reader = Reader::new(<span class="kw-2">&amp;</span>input[..]).unwrap();

<span class="comment">// value is a Result in case the read operation fails
</span><span class="kw">for </span>value <span class="kw">in </span>reader {
    <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, from_value::&lt;Test&gt;(<span class="kw-2">&amp;</span>value.unwrap()));
}</code></pre></div>
<h2 id="putting-everything-together"><a href="#putting-everything-together">Putting everything together</a></h2>
<p>The following is an example of how to combine everything showed so far and it is meant to be a
quick reference of the library interface:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>apache_avro::{Codec, Reader, Schema, Writer, from_value, types::Record, Error};
<span class="kw">use </span>serde::{Deserialize, Serialize};

<span class="attr">#[derive(Debug, Deserialize, Serialize)]
</span><span class="kw">struct </span>Test {
    a: i64,
    b: String,
}

<span class="kw">fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), Error&gt; {
    <span class="kw">let </span>raw_schema = <span class="string">r#&quot;
        {
            &quot;type&quot;: &quot;record&quot;,
            &quot;name&quot;: &quot;test&quot;,
            &quot;fields&quot;: [
                {&quot;name&quot;: &quot;a&quot;, &quot;type&quot;: &quot;long&quot;, &quot;default&quot;: 42},
                {&quot;name&quot;: &quot;b&quot;, &quot;type&quot;: &quot;string&quot;}
            ]
        }
    &quot;#</span>;

    <span class="kw">let </span>schema = Schema::parse_str(raw_schema)<span class="question-mark">?</span>;

    <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, schema);

    <span class="kw">let </span><span class="kw-2">mut </span>writer = Writer::with_codec(<span class="kw-2">&amp;</span>schema, Vec::new(), Codec::Deflate);

    <span class="kw">let </span><span class="kw-2">mut </span>record = Record::new(writer.schema()).unwrap();
    record.put(<span class="string">&quot;a&quot;</span>, <span class="number">27i64</span>);
    record.put(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;foo&quot;</span>);

    writer.append(record)<span class="question-mark">?</span>;

    <span class="kw">let </span>test = Test {
        a: <span class="number">27</span>,
        b: <span class="string">&quot;foo&quot;</span>.to_owned(),
    };

    writer.append_ser(test)<span class="question-mark">?</span>;

    <span class="kw">let </span>input = writer.into_inner()<span class="question-mark">?</span>;
    <span class="kw">let </span>reader = Reader::with_schema(<span class="kw-2">&amp;</span>schema, <span class="kw-2">&amp;</span>input[..])<span class="question-mark">?</span>;

    <span class="kw">for </span>record <span class="kw">in </span>reader {
        <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, from_value::&lt;Test&gt;(<span class="kw-2">&amp;</span>record<span class="question-mark">?</span>));
    }
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p><code>apache-avro</code> also supports the logical types listed in the <a href="https://avro.apache.org/docs/current/spec.html#Logical+Types">Avro specification</a>:</p>
<ol>
<li><code>Decimal</code> using the <a href="https://docs.rs/num-bigint/0.2.6/num_bigint"><code>num_bigint</code></a> crate</li>
<li>UUID using the <a href="https://docs.rs/uuid/1.0.0/uuid"><code>uuid</code></a> crate</li>
<li>Date, Time (milli) as <code>i32</code> and Time (micro) as <code>i64</code></li>
<li>Timestamp (milli and micro) as <code>i64</code></li>
<li>Duration as a custom type with <code>months</code>, <code>days</code> and <code>millis</code> accessor methods each of which returns an <code>i32</code></li>
</ol>
<p>Note that the on-disk representation is identical to the underlying primitive/complex type.</p>
<h4 id="read-and-write-logical-types"><a href="#read-and-write-logical-types">Read and write logical types</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>apache_avro::{
    types::Record, types::Value, Codec, Days, Decimal, Duration, Millis, Months, Reader, Schema,
    Writer, Error,
};
<span class="kw">use </span>num_bigint::ToBigInt;

<span class="kw">fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), Error&gt; {
    <span class="kw">let </span>raw_schema = <span class="string">r#&quot;
    {
      &quot;type&quot;: &quot;record&quot;,
      &quot;name&quot;: &quot;test&quot;,
      &quot;fields&quot;: [
        {
          &quot;name&quot;: &quot;decimal_fixed&quot;,
          &quot;type&quot;: {
            &quot;type&quot;: &quot;fixed&quot;,
            &quot;size&quot;: 2,
            &quot;name&quot;: &quot;decimal&quot;
          },
          &quot;logicalType&quot;: &quot;decimal&quot;,
          &quot;precision&quot;: 4,
          &quot;scale&quot;: 2
        },
        {
          &quot;name&quot;: &quot;decimal_var&quot;,
          &quot;type&quot;: &quot;bytes&quot;,
          &quot;logicalType&quot;: &quot;decimal&quot;,
          &quot;precision&quot;: 10,
          &quot;scale&quot;: 3
        },
        {
          &quot;name&quot;: &quot;uuid&quot;,
          &quot;type&quot;: &quot;string&quot;,
          &quot;logicalType&quot;: &quot;uuid&quot;
        },
        {
          &quot;name&quot;: &quot;date&quot;,
          &quot;type&quot;: &quot;int&quot;,
          &quot;logicalType&quot;: &quot;date&quot;
        },
        {
          &quot;name&quot;: &quot;time_millis&quot;,
          &quot;type&quot;: &quot;int&quot;,
          &quot;logicalType&quot;: &quot;time-millis&quot;
        },
        {
          &quot;name&quot;: &quot;time_micros&quot;,
          &quot;type&quot;: &quot;long&quot;,
          &quot;logicalType&quot;: &quot;time-micros&quot;
        },
        {
          &quot;name&quot;: &quot;timestamp_millis&quot;,
          &quot;type&quot;: &quot;long&quot;,
          &quot;logicalType&quot;: &quot;timestamp-millis&quot;
        },
        {
          &quot;name&quot;: &quot;timestamp_micros&quot;,
          &quot;type&quot;: &quot;long&quot;,
          &quot;logicalType&quot;: &quot;timestamp-micros&quot;
        },
        {
          &quot;name&quot;: &quot;duration&quot;,
          &quot;type&quot;: {
            &quot;type&quot;: &quot;fixed&quot;,
            &quot;size&quot;: 12,
            &quot;name&quot;: &quot;duration&quot;
          },
          &quot;logicalType&quot;: &quot;duration&quot;
        }
      ]
    }
    &quot;#</span>;

    <span class="kw">let </span>schema = Schema::parse_str(raw_schema)<span class="question-mark">?</span>;

    <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, schema);

    <span class="kw">let </span><span class="kw-2">mut </span>writer = Writer::with_codec(<span class="kw-2">&amp;</span>schema, Vec::new(), Codec::Deflate);

    <span class="kw">let </span><span class="kw-2">mut </span>record = Record::new(writer.schema()).unwrap();
    record.put(<span class="string">&quot;decimal_fixed&quot;</span>, Decimal::from(<span class="number">9936</span>.to_bigint().unwrap().to_signed_bytes_be()));
    record.put(<span class="string">&quot;decimal_var&quot;</span>, Decimal::from((-<span class="number">32442</span>.to_bigint().unwrap()).to_signed_bytes_be()));
    record.put(<span class="string">&quot;uuid&quot;</span>, uuid::Uuid::parse_str(<span class="string">&quot;550e8400-e29b-41d4-a716-446655440000&quot;</span>).unwrap());
    record.put(<span class="string">&quot;date&quot;</span>, Value::Date(<span class="number">1</span>));
    record.put(<span class="string">&quot;time_millis&quot;</span>, Value::TimeMillis(<span class="number">2</span>));
    record.put(<span class="string">&quot;time_micros&quot;</span>, Value::TimeMicros(<span class="number">3</span>));
    record.put(<span class="string">&quot;timestamp_millis&quot;</span>, Value::TimestampMillis(<span class="number">4</span>));
    record.put(<span class="string">&quot;timestamp_micros&quot;</span>, Value::TimestampMicros(<span class="number">5</span>));
    record.put(<span class="string">&quot;duration&quot;</span>, Duration::new(Months::new(<span class="number">6</span>), Days::new(<span class="number">7</span>), Millis::new(<span class="number">8</span>)));

    writer.append(record)<span class="question-mark">?</span>;

    <span class="kw">let </span>input = writer.into_inner()<span class="question-mark">?</span>;
    <span class="kw">let </span>reader = Reader::with_schema(<span class="kw-2">&amp;</span>schema, <span class="kw-2">&amp;</span>input[..])<span class="question-mark">?</span>;

    <span class="kw">for </span>record <span class="kw">in </span>reader {
        <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, record<span class="question-mark">?</span>);
    }
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<h3 id="calculate-avro-schema-fingerprint"><a href="#calculate-avro-schema-fingerprint">Calculate Avro schema fingerprint</a></h3>
<p>This library supports calculating the following fingerprints:</p>
<ul>
<li>SHA-256</li>
<li>MD5</li>
<li>Rabin</li>
</ul>
<p>An example of fingerprinting for the supported fingerprints:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>apache_avro::rabin::Rabin;
<span class="kw">use </span>apache_avro::{Schema, Error};
<span class="kw">use </span>md5::Md5;
<span class="kw">use </span>sha2::Sha256;

<span class="kw">fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), Error&gt; {
    <span class="kw">let </span>raw_schema = <span class="string">r#&quot;
        {
            &quot;type&quot;: &quot;record&quot;,
            &quot;name&quot;: &quot;test&quot;,
            &quot;fields&quot;: [
                {&quot;name&quot;: &quot;a&quot;, &quot;type&quot;: &quot;long&quot;, &quot;default&quot;: 42},
                {&quot;name&quot;: &quot;b&quot;, &quot;type&quot;: &quot;string&quot;}
            ]
        }
    &quot;#</span>;
    <span class="kw">let </span>schema = Schema::parse_str(raw_schema)<span class="question-mark">?</span>;
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, schema.fingerprint::&lt;Sha256&gt;());
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, schema.fingerprint::&lt;Md5&gt;());
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, schema.fingerprint::&lt;Rabin&gt;());
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<h3 id="ill-formed-data"><a href="#ill-formed-data">Ill-formed data</a></h3>
<p>In order to ease decoding, the Binary Encoding specification of Avro data
requires some fields to have their length encoded alongside the data.</p>
<p>If encoded data passed to a <code>Reader</code> has been ill-formed, it can happen that
the bytes meant to contain the length of data are bogus and could result
in extravagant memory allocation.</p>
<p>To shield users from ill-formed data, <code>apache-avro</code> sets a limit (default: 512MB)
to any allocation it will perform when decoding data.</p>
<p>If you expect some of your data fields to be larger than this limit, be sure
to make use of the <code>max_allocation_bytes</code> function before reading <strong>any</strong> data
(we leverage Rust’s <a href="https://doc.rust-lang.org/std/sync/struct.Once.html"><code>std::sync::Once</code></a>
mechanism to initialize this value, if
any call to decode is made before a call to <code>max_allocation_bytes</code>, the limit
will be 512MB throughout the lifetime of the program).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>apache_avro::max_allocation_bytes;

max_allocation_bytes(<span class="number">2 </span>* <span class="number">1024 </span>* <span class="number">1024 </span>* <span class="number">1024</span>);  <span class="comment">// 2GB

// ... happily decode large data
</span></code></pre></div>
<h3 id="check-schemas-compatibility"><a href="#check-schemas-compatibility">Check schemas compatibility</a></h3>
<p>This library supports checking for schemas compatibility.</p>
<p>Examples of checking for compatibility:</p>
<ol>
<li>Compatible schemas</li>
</ol>
<p>Explanation: an int array schema can be read by a long array schema- an int
(32bit signed integer) fits into a long (64bit signed integer)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>apache_avro::{Schema, schema_compatibility::SchemaCompatibility};

<span class="kw">let </span>writers_schema = Schema::parse_str(<span class="string">r#&quot;{&quot;type&quot;: &quot;array&quot;, &quot;items&quot;:&quot;int&quot;}&quot;#</span>).unwrap();
<span class="kw">let </span>readers_schema = Schema::parse_str(<span class="string">r#&quot;{&quot;type&quot;: &quot;array&quot;, &quot;items&quot;:&quot;long&quot;}&quot;#</span>).unwrap();
<span class="macro">assert_eq!</span>(<span class="bool-val">true</span>, SchemaCompatibility::can_read(<span class="kw-2">&amp;</span>writers_schema, <span class="kw-2">&amp;</span>readers_schema));</code></pre></div>
<ol start="2">
<li>Incompatible schemas (a long array schema cannot be read by an int array schema)</li>
</ol>
<p>Explanation: a long array schema cannot be read by an int array schema- a
long (64bit signed integer) does not fit into an int (32bit signed integer)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>apache_avro::{Schema, schema_compatibility::SchemaCompatibility};

<span class="kw">let </span>writers_schema = Schema::parse_str(<span class="string">r#&quot;{&quot;type&quot;: &quot;array&quot;, &quot;items&quot;:&quot;long&quot;}&quot;#</span>).unwrap();
<span class="kw">let </span>readers_schema = Schema::parse_str(<span class="string">r#&quot;{&quot;type&quot;: &quot;array&quot;, &quot;items&quot;:&quot;int&quot;}&quot;#</span>).unwrap();
<span class="macro">assert_eq!</span>(<span class="bool-val">false</span>, SchemaCompatibility::can_read(<span class="kw-2">&amp;</span>writers_schema, <span class="kw-2">&amp;</span>readers_schema));</code></pre></div>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><div class="item-table"><div class="item-row"><div class="item-left import-item" id="reexport.AvroSchema"><code>pub use schema::<a class="trait" href="schema/trait.AvroSchema.html" title="trait apache_avro::schema::AvroSchema">AvroSchema</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.Schema"><code>pub use schema::<a class="enum" href="schema/enum.Schema.html" title="enum apache_avro::schema::Schema">Schema</a>;</code></div></div></div><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="rabin/index.html" title="apache_avro::rabin mod">rabin</a></div><div class="item-right docblock-short">Implementation of the Rabin fingerprint algorithm</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="schema/index.html" title="apache_avro::schema mod">schema</a></div><div class="item-right docblock-short">Logic for parsing and interacting with schemas in Avro format.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="schema_compatibility/index.html" title="apache_avro::schema_compatibility mod">schema_compatibility</a></div><div class="item-right docblock-short">Logic for checking schema compatibility</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="types/index.html" title="apache_avro::types mod">types</a></div><div class="item-right docblock-short">Logic handling the intermediate representation of Avro values.</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Days.html" title="apache_avro::Days struct">Days</a></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Decimal.html" title="apache_avro::Decimal struct">Decimal</a></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Duration.html" title="apache_avro::Duration struct">Duration</a></div><div class="item-right docblock-short">A struct representing duration that hides the details of endianness and conversion between
platform-native u32 and byte arrays.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.GenericSingleObjectReader.html" title="apache_avro::GenericSingleObjectReader struct">GenericSingleObjectReader</a></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.GenericSingleObjectWriter.html" title="apache_avro::GenericSingleObjectWriter struct">GenericSingleObjectWriter</a></div><div class="item-right docblock-short">Writer that encodes messages according to the single object encoding v1 spec
Uses an API similar to the current File Writer
Writes all object bytes at once, and drains internal buffer</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Millis.html" title="apache_avro::Millis struct">Millis</a></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Months.html" title="apache_avro::Months struct">Months</a></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Reader.html" title="apache_avro::Reader struct">Reader</a></div><div class="item-right docblock-short">Main interface for reading Avro formatted values.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.SpecificSingleObjectReader.html" title="apache_avro::SpecificSingleObjectReader struct">SpecificSingleObjectReader</a></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.SpecificSingleObjectWriter.html" title="apache_avro::SpecificSingleObjectWriter struct">SpecificSingleObjectWriter</a></div><div class="item-right docblock-short">Writer that encodes messages according to the single object encoding v1 spec</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Writer.html" title="apache_avro::Writer struct">Writer</a></div><div class="item-right docblock-short">Main interface for writing Avro formatted values.</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Codec.html" title="apache_avro::Codec enum">Codec</a></div><div class="item-right docblock-short">The compression codec used to compress blocks.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Error.html" title="apache_avro::Error enum">Error</a></div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.from_avro_datum.html" title="apache_avro::from_avro_datum fn">from_avro_datum</a></div><div class="item-right docblock-short">Decode a <code>Value</code> encoded in Avro format given its <code>Schema</code> and anything implementing <code>io::Read</code>
to read from.</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.from_value.html" title="apache_avro::from_value fn">from_value</a></div><div class="item-right docblock-short">Interpret a <code>Value</code> as an instance of type <code>D</code>.</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.max_allocation_bytes.html" title="apache_avro::max_allocation_bytes fn">max_allocation_bytes</a></div><div class="item-right docblock-short">Set a new maximum number of bytes that can be allocated when decoding data.
Once called, the limit cannot be changed.</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.to_avro_datum.html" title="apache_avro::to_avro_datum fn">to_avro_datum</a></div><div class="item-right docblock-short">Encode a compatible value (implementing the <code>ToAvro</code> trait) into Avro format, also
performing schema validation.</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.to_value.html" title="apache_avro::to_value fn">to_value</a></div><div class="item-right docblock-short">Interpret a serializeable instance as a <code>Value</code>.</div></div></div><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="type" href="type.AvroResult.html" title="apache_avro::AvroResult type">AvroResult</a></div><div class="item-right docblock-short">A convenience type alias for <code>Result</code>s with <code>Error</code>s.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="apache_avro" data-themes="" data-resource-suffix="" data-rustdoc-version="1.68.0-nightly (5ce39f42b 2023-01-20)" data-search-js="search-98d53477a794af0b.js" data-settings-js="settings-c3c521c753752a1a.js" data-settings-css="settings-ab1d4ae2ec52020e.css" ></div></body></html>